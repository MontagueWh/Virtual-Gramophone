/* ==================================== JUCER_BINARY_RESOURCE ====================================

   This is an auto-generated file: Any edits you make may be overwritten!

*/

#include <cstring>

namespace BinaryData
{

//================== InfoButton.cpp ==================
static const unsigned char temp_binary_data_27[] =
"#include \"InfoButton.h\"\n"
"\n"
"InfoButton::InfoButton (juce::Colour colour)\n"
"{\n"
"    button.setButtonText (\"i\");\n"
"    button.addListener (this);\n"
"\n"
"    info_text.setColour (juce::Label::backgroundColourId, colour);\n"
"    info_text.setColour (juce::Label::outlineColourId, juce::Colours::white);\n"
"    info_text.setColour (juce::Label::textColourId, juce::Colours::lightgrey);\n"
"    info_text.setJustificationType (juce::Justification::centredLeft);\n"
"    info_text.setBorderSize (juce::BorderSize<int> (20, 70, 20, 70));\n"
"\n"
"    std::string info_string = \"\";\n"
"    info_string += ProjectInfo::companyName + std::string (\" \") + ProjectInfo::projectName + std::string (\" version \") + ProjectInfo::versionString + std::string (\"\\n\\n\");\n"
"    info_string += std::string (\"by Montague Whishaw\\n\\n\");\n"
"    info_string += std::string (\"Check out my other projects at https://github.com/MontagueWh\");\n"
"\n"
"    info_text.setText (info_string, juce::dontSendNotification);\n"
"}\n"
"\n"
"InfoButton::~InfoButton() {}\n"
"\n"
"void InfoButton::addToEditor (juce::AudioProcessorEditor* editor)\n"
"{\n"
"    editor->addAndMakeVisible (info_text);\n"
"    info_text.setVisible (false);\n"
"    editor->addAndMakeVisible (button);\n"
"}\n"
"\n"
"void InfoButton::buttonStateChanged (juce::Button* b)\n"
"{\n"
"    if (b == &button)\n"
"    {\n"
"        if (button.isOver())\n"
"        {\n"
"            info_text.setVisible (true);\n"
"        }\n"
"        else\n"
"        {\n"
"            info_text.setVisible (false);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"void InfoButton::buttonClicked (juce::Button* button)\n"
"{\n"
"}\n";

const char* InfoButton_cpp = (const char*) temp_binary_data_27;

//================== InfoButton.h ==================
static const unsigned char temp_binary_data_28[] =
"#pragma once\n"
"\n"
"#include <JuceHeader.h>\n"
"\n"
"// Use the info button class by\n"
"// 1) Create an InfoButton object\n"
"// 2) Make the button visible by  using the function addToEditor(this) from PluginEditor class\n"
"// 3) In resized() function set boundry of the public data members button and info_text\n"
"class InfoButton : public juce::Button::Listener\n"
"{\n"
"public:\n"
"    explicit InfoButton (juce::Colour colour);\n"
"    ~InfoButton();\n"
"    void addToEditor (juce::AudioProcessorEditor* editor);\n"
"    void buttonStateChanged (juce::Button* b) override;\n"
"    void buttonClicked (juce::Button* button) override;\n"
"    juce::TextButton button;\n"
"    juce::Label info_text;\n"
"};\n";

const char* InfoButton_h = (const char*) temp_binary_data_28;

//================== PluginProcessor.cpp ==================
static const unsigned char temp_binary_data_29[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin processor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor class.\n"
"#include \"PluginEditor.h\"    // Includes the header file for the plugin editor class.\n"
"\n"
"constexpr float BP_FREQ = 2950.0f; // Defines a constant for the band-pass filter frequency.\n"
"\n"
"//==============================================================================\n"
"// Constructor for the plugin processor class.\n"
"VirtualGramoAudioProcessor::VirtualGramoAudioProcessor()\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"    : AudioProcessor(BusesProperties() // Initialises the audio processor with bus properties.\n"
"#if ! JucePlugin_IsMidiEffect\n"
"#if ! JucePlugin_IsSynth\n"
"        .withInput(\"Input\", juce::AudioChannelSet::discreteChannels(MAX_CHANNELS), true) // Adds the number of input busses\n"
"#endif\n"
"        .withOutput(\"Output\", juce::AudioChannelSet::discreteChannels(MAX_CHANNELS), true) // Adds the number of output busses\n"
"#endif\n"
"    ),\n"
"    apvts(*this, nullptr, \"Parameters\", createParameters()) // Initialises the AudioProcessorValueTreeState for parameter management.\n"
"#endif\n"
"{\n"
"}\n"
"\n"
"VirtualGramoAudioProcessor::~VirtualGramoAudioProcessor()\n"
"{\n"
"    // Destructor for the plugin processor class. Cleans up resources if necessary.\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Returns the name of the plugin.\n"
"const juce::String VirtualGramoAudioProcessor::getName() const\n"
"{\n"
"    return JucePlugin_Name; // Uses the name defined in the JUCE plugin configuration.\n"
"}\n"
"\n"
"// Determines if the plugin accepts MIDI input.\n"
"bool VirtualGramoAudioProcessor::acceptsMidi() const\n"
"{\n"
"#if JucePlugin_WantsMidiInput\n"
"    return true; // Returns true if the plugin is configured to accept MIDI input.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Determines if the plugin produces MIDI output.\n"
"bool VirtualGramoAudioProcessor::producesMidi() const\n"
"{\n"
"#if JucePlugin_ProducesMidiOutput\n"
"    return true; // Returns true if the plugin is configured to produce MIDI output.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Determines if the plugin is a MIDI effect.\n"
"bool VirtualGramoAudioProcessor::isMidiEffect() const\n"
"{\n"
"#if JucePlugin_IsMidiEffect\n"
"    return true; // Returns true if the plugin is a MIDI effect.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Returns the tail length of the plugin in seconds.\n"
"double VirtualGramoAudioProcessor::getTailLengthSeconds() const\n"
"{\n"
"    return 0.0; // No tail length is defined for this plugin.\n"
"}\n"
"\n"
"// Returns the number of programs (presets) available in the plugin.\n"
"int VirtualGramoAudioProcessor::getNumPrograms()\n"
"{\n"
"    return 1; // At least one program is required, even if not implemented.\n"
"}\n"
"\n"
"// Returns the index of the current program.\n"
"int VirtualGramoAudioProcessor::getCurrentProgram()\n"
"{\n"
"    return 0; // Only one program is available, so the index is always 0.\n"
"}\n"
"\n"
"// Sets the current program (not implemented in this plugin).\n"
"void VirtualGramoAudioProcessor::setCurrentProgram(int /*index*/)\n"
"{\n"
"}\n"
"\n"
"// Returns the name of the program at the given index (not implemented).\n"
"const juce::String VirtualGramoAudioProcessor::getProgramName(int /*index*/)\n"
"{\n"
"    return {}; // Returns an empty string.\n"
"}\n"
"\n"
"// Changes the name of the program at the given index (not implemented).\n"
"void VirtualGramoAudioProcessor::changeProgramName(int /*index*/, const juce::String& /*newName*/)\n"
"{\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Prepares the plugin for playback by initialising DSP components.\n"
"void VirtualGramoAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)\n"
"{\n"
"    // Sets up the processing specification for DSP components.\n"
"    juce::dsp::ProcessSpec spec = { sampleRate, static_cast<juce::uint32>(samplesPerBlock),\n"
"                                    static_cast<juce::uint32>(getMainBusNumOutputChannels()) };\n"
"\n"
"    PrepareAdditionalEffects(spec, sampleRate);\n"
"\n"
"\tgramoVoice.prepareToPlay(sampleRate, samplesPerBlock); // Prepares the GramoVoice for playback.\n"
"}\n"
"\n"
"// Releases resources when playback stops.\n"
"void VirtualGramoAudioProcessor::releaseResources()\n"
"{\n"
"    // Frees up any resources or memory used during playback.\n"
"\n"
"    \n"
"}\n"
"\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"// Checks if the given bus layout is supported by the plugin.\n"
"bool VirtualGramoAudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const\n"
"{\n"
"#if JucePlugin_IsMidiEffect\n"
"    juce::ignoreUnused(layouts);\n"
"    return true; // MIDI effects support all layouts.\n"
"#else\n"
"    // Allow any valid output channel configuration\n"
"    const auto& outputSet = layouts.getMainOutputChannelSet();\n"
"\n"
"    // Ensure the layout is valid and not empty\n"
"    if (outputSet.isDisabled())\n"
"        return false;\n"
"\n"
"    // Ensures the input layout matches the output layout for non-synth plugins.\n"
"#if ! JucePlugin_IsSynth\n"
"    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\n"
"        return false;\n"
"#endif\n"
"\n"
"    return true; // Layout is supported.\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"// Processes audio and MIDI data for each block of samples.\n"
"void VirtualGramoAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)\n"
"{\n"
"    juce::ScopedNoDenormals noDenormals; // Ensures denormalized numbers are handled correctly.\n"
"    auto totalNumInputChannels = getTotalNumInputChannels(); // Gets the number of input channels.\n"
"    auto totalNumOutputChannels = getTotalNumOutputChannels(); // Gets the number of output channels.\n"
"\n"
"    gramoVoice.processInputAudio(buffer);\n"
"    gramoVoice.processBlock(buffer, midiMessages); // Processes the audio data using the GramoVoice.\n"
"    mix.pushDrySamples(buffer); // Pushes the dry signal into the mix processor.\n"
"\n"
"    // Processes each sample in the buffer.\n"
"    for (int sample = 0; sample < buffer.getNumSamples(); ++sample)\n"
"    {\n"
"        for (int channel = 0; channel < totalNumInputChannels; ++channel)\n"
"        {            \n"
"            ProcessCompressionAndTone(buffer, channel, sample);\n"
"        }\n"
"    }\n"
"\n"
"    // Wraps the buffer in an AudioBlock for further processing.\n"
"    auto block = juce::dsp::AudioBlock<float>(buffer);\n"
"    auto contextToUse = juce::dsp::ProcessContextReplacing<float>(block);\n"
"\n"
"    ProcessChorusEffect(contextToUse);\n"
"\n"
"    // Configures and applies the wet/dry mix.\n"
"    mix.setWetMixProportion(1.0f - apvts.getRawParameterValue(\"MIX\")->load());\n"
"    mix.mixWetSamples(block);\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Indicates whether the plugin has an editor.\n"
"bool VirtualGramoAudioProcessor::hasEditor() const\n"
"{\n"
"    return true; // Returns true to indicate the plugin has a GUI editor.\n"
"}\n"
"\n"
"// Creates and returns the plugin editor.\n"
"juce::AudioProcessorEditor* VirtualGramoAudioProcessor::createEditor()\n"
"{\n"
"    return new VirtualGramoAudioProcessorEditor(*this); // Creates an instance of the editor.\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Saves the plugin's state to a memory block.\n"
"void VirtualGramoAudioProcessor::getStateInformation(juce::MemoryBlock& destData)\n"
"{\n"
"    auto state = apvts.copyState(); // Copies the current state of the parameters.\n"
"    std::unique_ptr<juce::XmlElement> xml(state.createXml()); // Converts the state to XML.\n"
"    copyXmlToBinary(*xml, destData); // Saves the XML to the memory block.\n"
"}\n"
"\n"
"// Restores the plugin's state from a memory block.\n"
"void VirtualGramoAudioProcessor::setStateInformation(const void* data, int sizeInBytes)\n"
"{\n"
"    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes)); // Reads XML from the memory block.\n"
"\n"
"    if (xmlState.get() != nullptr)\n"
"        if (xmlState->hasTagName(apvts.state.getType())) // Checks if the XML tag matches the parameter tree type.\n"
"            apvts.replaceState(juce::ValueTree::fromXml(*xmlState)); // Restores the state from the XML.\n"
"}\n"
"\n"
"// Creates and returns the parameter layout for the plugin.\n"
"juce::AudioProcessorValueTreeState::ParameterLayout VirtualGramoAudioProcessor::createParameters()\n"
"{\n"
"    std::vector<std::unique_ptr<juce::RangedAudioParameter>> parameters; // Stores the parameters.\n"
"\n"
"    // Adds parameters for compression, vibrato, tone, and mix.\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"COMPRESS\", \"Compress\", 0.04f, 0.45f, 0.1f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"VIBRATO\", \"Vibrato\", 0.0f, 0.33f, 0.01f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"VIBRATO_RATE\", \"Rate\", 0.5f, 4.0f, 2.0f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"TONE\", \"Tone\", 320.1f, 4700.0f, 2000.0f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"MIX\", \"Mix\", 0.0f, 0.5f, 0.0f));\n"
"    return { parameters.begin(), parameters.end() }; // Returns the parameter layout.\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Factory function to create a new instance of the plugin.\n"
"juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()\n"
"{\n"
"    return new VirtualGramoAudioProcessor(); // Creates and returns a new instance of the processor.\n"
"}\n"
"\n"
"void VirtualGramoAudioProcessor::PrepareAdditionalEffects(juce::dsp::ProcessSpec& spec, double sampleRate)\n"
"{\n"
"    filterCount = getTotalNumOutputChannels(); // Sets the number of filters to the number of output channels.\n"
"    filters.resize(filterCount); // Resizes the filter vector to match the number of channels.\n"
"\n"
"    chorus.prepare(spec); // Prepares the chorus effect with the processing spec.\n"
"    mix.prepare(spec);    // Prepares the wet/dry mix processor.\n"
"\n"
"    // Retrieves the initial frequency value from the parameter tree.\n"
"    float frequency = apvts.getRawParameterValue(\"TONE\")->load();\n"
"\n"
"    // Prepares and configures the band-pass filters for each channel.\n"
"    for (int i = 0; i < filterCount; ++i)\n"
"    {\n"
"        filters[i].prepare(spec); // Prepares each filter with the processing spec.\n"
"        filters[i].coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(sampleRate, frequency, 6.0f); // Sets the filter coefficients.\n"
"    }\n"
"}\n"
"\n"
"\n"
"void VirtualGramoAudioProcessor::ProcessChorusEffect(juce::dsp::ProcessContextReplacing<float>& contextToUse)\n"
"{\n"
"    // Configures and processes the chorus effect.\n"
"    chorus.setRate(apvts.getRawParameterValue(\"VIBRATO_RATE\")->load());\n"
"    chorus.setDepth(apvts.getRawParameterValue(\"VIBRATO\")->load());\n"
"    chorus.setCentreDelay(1.0f);\n"
"    chorus.setFeedback(0.0f);\n"
"    chorus.setMix(1.0f);\n"
"    chorus.process(contextToUse);\n"
"}\n"
"\n"
"void VirtualGramoAudioProcessor::ProcessCompressionAndTone(juce::AudioSampleBuffer& buffer, int channel, int sample)\n"
"{\n"
"    // Retrieves parameter values for compression and tone.\n"
"    float threshold = apvts.getRawParameterValue(\"COMPRESS\")->load();\n"
"    float frequency = apvts.getRawParameterValue(\"TONE\")->load();\n"
"\n"
"    // Apply compression\n"
"    float in = buffer.getReadPointer(channel)[sample];\n"
"    if (in >= threshold)\n"
"        buffer.getWritePointer(channel)[sample] = (in / 4) + (3 * threshold / 4);\n"
"    else if (in <= -threshold)\n"
"        buffer.getWritePointer(channel)[sample] = (in / 4) - (3 * threshold / 4);\n"
"\n"
"    // Applies makeup gain to the signal.\n"
"    *buffer.getWritePointer(channel, sample) *= 5.0f - (11.0f * threshold * threshold);\n"
"\n"
"    // Applies a band-pass filter to the signal for each channel\n"
"    for (int i = 0; i < filterCount; ++i)\n"
"    {\n"
"        filters[i].coefficients = *juce::dsp::IIR::Coefficients<float>::makeBandPass(getSampleRate(), frequency, 2.7f);\n"
"        buffer.getWritePointer(channel)[sample] = filters[i].processSample(buffer.getReadPointer(channel)[sample]);\n"
"    }\n"
"}";

const char* PluginProcessor_cpp = (const char*) temp_binary_data_29;

//================== PluginProcessor.h ==================
static const unsigned char temp_binary_data_30[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin processor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#pragma once // Ensures the file is included only once during compilation.\n"
"\n"
"#include <JuceHeader.h> // Includes the JUCE framework header file.\n"
"#include \"Process/GramoVoice.h\" // Includes the GramoVoice class header file for audio processing.\n"
"\n"
"static const int MAX_CHANNELS = 64;\n"
"\n"
"//==============================================================================\n"
"/**\n"
" * The main audio processor class for the plugin.\n"
" * Inherits from juce::AudioProcessor and implements its virtual methods.\n"
" */\n"
"class VirtualGramoAudioProcessor : public juce::AudioProcessor\n"
"{\n"
"public:\n"
"\n"
"    //==============================================================================\n"
"    VirtualGramoAudioProcessor(); // Constructor for the audio processor.\n"
"    ~VirtualGramoAudioProcessor() override; // Destructor for the audio processor.\n"
"\n"
"    //==============================================================================\n"
"    void prepareToPlay(double sampleRate, int samplesPerBlock) override; // Prepares the processor for playback by initialising resources\n"
"\n"
"    void PrepareAdditionalEffects(juce::dsp::ProcessSpec& spec, double sampleRate);\n"
"    \n"
"    void releaseResources() override; // Releases resources when playback stops.\n"
"\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"    bool isBusesLayoutSupported(const BusesLayout& layouts) const override; // Checks if the given bus layout is supported by the plugin\n"
"#endif\n"
"    \n"
"    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override; // Processes audio and MIDI data for each block of samples\n"
"\n"
"    void ProcessChorusEffect(juce::dsp::ProcessContextReplacing<float>& contextToUse);\n"
"\n"
"    void ProcessCompressionAndTone(juce::AudioSampleBuffer& buffer, int channel, int sample);\n"
"\n"
"    //==============================================================================\n"
"    juce::AudioProcessorEditor* createEditor() override; // Creates and returns the plugin editor (GUI)\n"
"\n"
"    bool hasEditor() const override; // Indicates whether the plugin has an editor (GUI)\n"
"\n"
"    //==============================================================================\n"
"    const juce::String getName() const override; // Returns the name of the plugin\n"
"    \n"
"    bool acceptsMidi() const override; // Determines if the plugin accepts MIDI input\n"
"\tbool producesMidi() const override; // Determines if the plugin produces MIDI output\n"
"    bool isMidiEffect() const override; // Determines if the plugin is a MIDI effect\n"
"\n"
"    double getTailLengthSeconds() const override; // Returns the tail length of the plugin in seconds\n"
"\n"
"    //==============================================================================\n"
"    int getNumPrograms() override; // Returns the number of programs (presets) available in the plugin\n"
"    int getCurrentProgram() override; // Returns the index of the current program\n"
"    void setCurrentProgram(int index) override; // Sets the current program (preset) by index.\n"
"\n"
"    const juce::String getProgramName(int index) override; // Returns the name of the program (preset) at the given index\n"
"    void changeProgramName(int index, const juce::String& newName) override; // Changes the name of the program (preset) at the given index\n"
"\n"
"    //==============================================================================\n"
"    void getStateInformation(juce::MemoryBlock& destData) override; // Saves the plugin's state to a memory block\n"
"\n"
"    void setStateInformation(const void* data, int sizeInBytes) override; // Restores the plugin's state from a memory block\n"
"\n"
"    juce::AudioProcessorValueTreeState apvts; // Manages the plugin's parameters using a value tree state.\n"
"\n"
"private:\n"
"\n"
"\t//==============================================================================\n"
"    // Creates and returns the parameter layout for the plugin.\n"
"    juce::AudioProcessorValueTreeState::ParameterLayout createParameters();\n"
"\n"
"    // DSP components used in the plugin.\n"
"    juce::dsp::Chorus<float> chorus; // Chorus effect processor.\n"
"    int filterCount;\n"
"    std::vector<juce::dsp::IIR::Filter<float>> filters;\n"
"    juce::dsp::DryWetMixer<float> mix; // Wet/dry mix processor.\n"
"\n"
"\tGramoVoice gramoVoice; // Instance of the GramoVoice class for audio processing.\n"
"\n"
"    //==============================================================================\n"
"    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VirtualGramoAudioProcessor)\n"
"        // Macro to prevent copying and enable leak detection for the class.\n"
"};";

const char* PluginProcessor_h = (const char*) temp_binary_data_30;

//================== PluginEditor.cpp ==================
static const unsigned char temp_binary_data_31[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin editor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#include \"PluginEditor.h\" // Includes the header file for the plugin editor.\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor.\n"
"\n"
"\n"
"constexpr float LINE_THICKNESS = 4.0f; // Defines the thickness of lines drawn in the editor.\n"
"\n"
"//==============================================================================\n"
"// Constructor for the plugin editor.\n"
"VirtualGramoAudioProcessorEditor::VirtualGramoAudioProcessorEditor(VirtualGramoAudioProcessor& p)\n"
"    : AudioProcessorEditor(&p), audioProcessor(p), info_button_(juce::Colours::darkgrey)\n"
"{\n"
"    constexpr int TEXT_BOX_SIZE = 25; // Defines the size of the text box for sliders.\n"
"\n"
"    additionalEffectsParamsSetup(TEXT_BOX_SIZE);\n"
"    gramophoneHornParamsSetup(TEXT_BOX_SIZE);\n"
"    wetDryParamSetup(TEXT_BOX_SIZE);\n"
"\n"
"    // Adds the info button to the editor.\n"
"    info_button_.addToEditor(this);\n"
"\n"
"\t//addAndMakeVisible(gramoModelLoader); // Adds the model loader to the editor.\n"
"\n"
"    setSize(1500, 1500); // Sets the initial size of the editor window.\n"
"\tsetResizable(true, true);\n"
"}\n"
"\n"
"// Destructor for the plugin editor.\n"
"VirtualGramoAudioProcessorEditor::~VirtualGramoAudioProcessorEditor()\n"
"{\n"
"    \n"
"}\n"
"\n"
"//==============================================================================\n"
"// Paints the editor's GUI components.\n"
"void VirtualGramoAudioProcessorEditor::paint(juce::Graphics& g)\n"
"{\n"
"    // (Our component is opaque, so we must completely fill the background with a solid colour)\n"
"    g.fillAll(juce::Colours::beige);\n"
"\n"
"    g.setColour(juce::Colour(0xff123456));\n"
"    g.setFont(40.0f);\n"
"    g.drawFittedText(\"Virtual Gramophone\", getLocalBounds(), juce::Justification::centredTop, 1);\n"
"\n"
"    setupSections();\n"
"\n"
"    g.setFont(18.0f);\n"
"    g.drawFittedText(\"COMP\", compressTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"TONE\", toneTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"VIBE\", vibratoTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"DRY\", wetDryTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"HORN STIFFNESS\", hornStiffnessTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"HORN DIAMETER\", hornDiameterTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"HORN LENGTH\", hornLengthTextSection, juce::Justification::left, 1);\n"
"}\n"
"\n"
"// Converts a slider's value to an alpha (transparency) value.\n"
"float VirtualGramoAudioProcessorEditor::sliderToAplhaValue(juce::Slider& slider)\n"
"{\n"
"    double range = (slider.getMaximum() - slider.getMinimum());\n"
"    return static_cast<float>((slider.getValue() - slider.getMinimum()) / range);\n"
"}\n"
"\n"
"// Handles resizing and layout of GUI components.\n"
"void VirtualGramoAudioProcessorEditor::resized()\n"
"{\n"
"    info_button_.button.setBounds(getWidth() - 35, 10, 20, 20); // Positions the info button.\n"
"    info_button_.info_text.setBounds(30, 50, getWidth() - 60, getHeight() - 100); // Positions the info text.\n"
"    setupSections(); // Updates the layout sections.\n"
"    compressThreshParam.setBounds(compressSection); // Positions the compression slider.\n"
"    toneParam.setBounds(toneSection); // Positions the tone slider.\n"
"    vibratoDepthParam.setBounds(vibratoDepthSection); // Positions the vibrato slider.\n"
"    vibratoRateParam.setBounds(vibratoRateSection); // Positions the vibrato rate slider.\n"
"    wetDryParam.setBounds(wetDrySection); // Positions the mix slider.\n"
"\n"
"\n"
"    std::string GramoSuite = \"../Source/UI/GramoSuite.fbx\";\n"
"    //gramoModelLoader.importModel(GramoSuite); // Import the model from the specified path\n"
"    //gramoModelLoader.setBounds(pictureSection);\n"
"}\n"
"\n"
"// Sets up the layout sections for the GUI.\n"
"void VirtualGramoAudioProcessorEditor::setupSections()\n"
"{    \n"
"    juce::Rectangle<int> r = getLocalBounds(); // Gets the bounds of the editor.\n"
"    topSection = r.removeFromTop(50); // Allocates the top section.\n"
"    pictureSection = r.removeFromLeft(310); // Allocates the picture section.\n"
"\n"
"    juce::Rectangle<int> interfaceSection = r; // Remaining area for the interface.\n"
"    int sectionHeight = interfaceSection.getHeight() / 4; // Divides the interface into four sections.\n"
"    constexpr int textSectionWidth = 40; // Width for the text labels.\n"
"\n"
"    // Allocates sections for sliders and their labels.\n"
"    compressSection = interfaceSection.removeFromTop(sectionHeight);\n"
"    compressTextSection = compressSection.removeFromLeft(textSectionWidth);\n"
"\n"
"\ttoneSection = interfaceSection.removeFromTop(sectionHeight);\n"
"\ttoneTextSection = toneSection.removeFromLeft(textSectionWidth);\n"
"\n"
"\tvibratoDepthSection = interfaceSection.removeFromTop(sectionHeight);\n"
"\tvibratoTextSection = vibratoDepthSection.removeFromLeft(textSectionWidth);\n"
"\tvibratoRateSection = interfaceSection.removeFromTop(sectionHeight);\n"
"\n"
"    wetDrySection = interfaceSection;\n"
"    wetDrySection = interfaceSection.removeFromTop(textSectionWidth);\n"
"\n"
"    hornStiffnessSection = interfaceSection.removeFromTop(sectionHeight);\n"
"    hornStiffnessTextSection = hornStiffnessSection.removeFromLeft(40);\n"
"\n"
"    hornDiameterSection = interfaceSection.removeFromTop(sectionHeight);\n"
"    hornDiameterTextSection = hornDiameterSection.removeFromLeft(40);\n"
"\n"
"    hornLengthSection = interfaceSection.removeFromTop(sectionHeight);\n"
"    hornLengthTextSection = hornLengthSection.removeFromLeft(40);\n"
"}\n"
"\n"
"void VirtualGramoAudioProcessorEditor::additionalEffectsParamsSetup(const int TEXT_BOX_SIZE)\n"
"{\n"
"    // Sets up the compression slider.\n"
"    compressThreshParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag); // Rotary slider style.\n"
"    compressThreshParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE); // No text box for the slider.\n"
"    compressThreshParam.addListener(this); // Adds this editor as a listener for slider changes.\n"
"    addAndMakeVisible(compressThreshParam); // Makes the slider visible in the editor.\n"
"\n"
"    // Links the compression slider to the \"COMPRESS\" parameter in the processor's parameter tree.\n"
"    compressThreshAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"COMPRESS\", compressThreshParam);\n"
"\n"
"    // Sets up the tone slider.\n"
"    toneParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    toneParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    toneParam.addListener(this);\n"
"    addAndMakeVisible(toneParam);\n"
"    toneAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"TONE\", toneParam);\n"
"\n"
"    // Sets up the vibrato slider.\n"
"    vibratoDepthParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    vibratoDepthParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    vibratoDepthParam.addListener(this);\n"
"    addAndMakeVisible(vibratoDepthParam);\n"
"    vibratoDepthAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"VIBRATO_DEPTH\", vibratoDepthParam);\n"
"\n"
"    // Sets up the vibrato rate slider.\n"
"    vibratoRateParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    vibratoRateParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    vibratoRateParam.addListener(this);\n"
"    addAndMakeVisible(vibratoRateParam);\n"
"    vibratoRateAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"VIBRATO_RATE\", vibratoRateParam);\n"
"}\n"
"void VirtualGramoAudioProcessorEditor::wetDryParamSetup(const int TEXT_BOX_SIZE)\n"
"{\n"
"    // Sets up the mix slider.\n"
"    wetDryParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    wetDryParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    wetDryParam.addListener(this);\n"
"    addAndMakeVisible(wetDryParam);\n"
"    wetDryAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"MIX\", wetDryParam);\n"
"}\n"
"\n"
"void VirtualGramoAudioProcessorEditor::gramophoneHornParamsSetup(const int TEXT_BOX_SIZE)\n"
"{\n"
"    // Add slider for the gramophone horn's stiffness\n"
"    hornStiffnessParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    hornStiffnessParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    hornStiffnessParam.addListener(this);\n"
"    addAndMakeVisible(hornStiffnessParam);\n"
"    hornStiffnessAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"HORN_STIFFNESS\", hornStiffnessParam);\n"
"\n"
"    hornDiameterParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    hornDiameterParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    hornDiameterParam.addListener(this);\n"
"    addAndMakeVisible(hornDiameterParam);\n"
"    hornDiameterAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"HORN_DIAMETER\", hornDiameterParam);\n"
"}\n"
"\n"
"// Callback for when a slider's value changes.\n"
"void VirtualGramoAudioProcessorEditor::sliderValueChanged(juce::Slider* /*slider*/)\n"
"{\n"
"    repaint(); // Repaints the editor to reflect the updated slider value.\n"
"}";

const char* PluginEditor_cpp = (const char*) temp_binary_data_31;

//================== PluginEditor.h ==================
static const unsigned char temp_binary_data_32[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin editor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#pragma once // Ensures the file is included only once during compilation.\n"
"\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor.\n"
"#include \"UI/InfoButton.h\"      // Includes the header file for the InfoButton class.\n"
"#include <JuceHeader.h>      // Includes the JUCE framework header file.\n"
"//#include <../Source/UI/GramoModelLoader.h>\n"
"\n"
"\n"
"//==============================================================================\n"
"/**\n"
" * The main editor class for the plugin.\n"
" * Inherits from juce::AudioProcessorEditor and juce::Slider::Listener.\n"
" * Handles the GUI and user interactions for the plugin.\n"
" */\n"
"class VirtualGramoAudioProcessorEditor : public juce::AudioProcessorEditor,\n"
"    public juce::Slider::Listener\n"
"{\n"
"public:\n"
"    explicit VirtualGramoAudioProcessorEditor(VirtualGramoAudioProcessor&); // Constructor that takes a reference to the audio processor.\n"
"    void gramophoneHornParamsSetup(const int TEXT_BOX_SIZE);\n"
"    void wetDryParamSetup(const int TEXT_BOX_SIZE);\n"
"    void additionalEffectsParamsSetup(const int TEXT_BOX_SIZE);\n"
"    ~VirtualGramoAudioProcessorEditor() override; // Destructor for the editor.\n"
"\n"
"    //==============================================================================\n"
"    void paint(juce::Graphics&) override; // Paints the editor's GUI components.\n"
"    void resized() override; // Handles resizing and layout of GUI components.\n"
"\n"
"\n"
"private:\n"
"    float sliderToAplhaValue(juce::Slider& slider); // Converts a slider's value to an alpha (transparency) value.\n"
"    void setupSections(); // Sets up the layout and sections of the GUI.\n"
"    void sliderValueChanged(juce::Slider* slider) override; // Callback for when a slider's value changes.\n"
"\n"
"    InfoButton info_button_; // Custom button for displaying information about the plugin.\n"
"\n"
"    // Type alias for a unique pointer to a SliderAttachment.\n"
"    typedef std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> SliderAttatchmentPtr;\n"
"\n"
"    // Sliders for controlling various parameters of the plugin.\n"
"    juce::Slider compressThreshParam; // Slider for controlling the compression parameter.\n"
"    SliderAttatchmentPtr compressThreshAttach; // Attachment to link the compress slider to the parameter tree.\n"
"\n"
"    juce::Slider toneParam; // Slider for controlling the tone parameter.\n"
"    SliderAttatchmentPtr toneAttach; // Attachment to link the tone slider to the parameter tree.\n"
"\n"
"    juce::Slider vibratoDepthParam; // Slider for controlling the vibrato depth parameter.\n"
"    SliderAttatchmentPtr vibratoDepthAttach; // Attachment to link the vibrato slider to the parameter tree.\n"
"\n"
"    juce::Slider vibratoRateParam; // Slider for controlling the vibrato rate parameter.\n"
"    SliderAttatchmentPtr vibratoRateAttach; // Attachment to link the vibrato rate slider to the parameter tree.\n"
"\n"
"    juce::Slider wetDryParam; // Slider for controlling the wet/dry mix parameter.\n"
"    SliderAttatchmentPtr wetDryAttach; // Attachment to link the mix slider to the parameter tree.\n"
"\n"
"    juce::Slider hornStiffnessParam; // Slider for changing the stiffness of the gramophone's brass horn\n"
"\tSliderAttatchmentPtr hornStiffnessAttach; // Attachment to link the horn stiffness slider to the parameter tree.\n"
"\n"
"    juce::Slider hornDiameterParam; // Slider for changing the diameter of the gramophone's brass horn\n"
"\tSliderAttatchmentPtr hornDiameterAttach; // Attachment to link the horn diameter slider to the parameter tree.\n"
"\n"
"\tjuce::Slider hornLengthParam; // Slider for changing the length of the gramophone's brass horn\n"
"\tSliderAttatchmentPtr hornLengthAttach; // Attachment to link the horn length slider to the parameter tree.\n"
"\n"
"    // Rectangles defining sections of the GUI layout.\n"
"    juce::Rectangle<int> topSection; // Rectangle for the top section of the GUI.\n"
"    juce::Rectangle<int> pictureSection; // Rectangle for the picture section of the GUI.\n"
"    juce::Rectangle<int> compressSection; // Rectangle for the compression slider section.\n"
"    juce::Rectangle<int> toneSection; // Rectangle for the tone slider section.\n"
"    juce::Rectangle<int> vibratoDepthSection; // Rectangle for the vibrato slider section.\n"
"    juce::Rectangle<int> vibratoRateSection; // Rectangle for the vibrato rate slider section.\n"
"    juce::Rectangle<int> wetDrySection; // Rectangle for the mix slider section.\n"
"\n"
"    juce::Rectangle<int> compressTextSection; // Rectangle for the compression text label section.\n"
"    juce::Rectangle<int> toneTextSection; // Rectangle for the tone text label section.\n"
"    juce::Rectangle<int> vibratoTextSection; // Rectangle for the vibrato text label section.\n"
"    juce::Rectangle<int> wetDryTextSection; // Rectangle for the mix text label section.\n"
"\n"
"\n"
"\tjuce::Rectangle<int> hornStiffnessSection; // Rectangle for the horn stiffness text label section.\n"
"\tjuce::Rectangle<int> hornDiameterSection; // Rectangle for the horn diameter text label section.\n"
"\tjuce::Rectangle<int> hornLengthSection; // Rectangle for the horn length text label section.\n"
"\n"
"\tjuce::Rectangle<int> hornStiffnessTextSection; // Rectangle for the horn stiffness text label section.\n"
"\tjuce::Rectangle<int> hornDiameterTextSection; // Rectangle for the horn diameter text label section.\n"
"\tjuce::Rectangle<int> hornLengthTextSection; // Rectangle for the horn length text label section.\n"
"\n"
"\t//GramoModelLoader gramoModelLoader; // Instance of the GramoModelLoader class for loading 3D models.\n"
"\n"
"    VirtualGramoAudioProcessor& audioProcessor; // Reference to the audio processor instance.\n"
"\n"
"    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VirtualGramoAudioProcessorEditor)\n"
"        // Macro to prevent copying and enable leak detection for the class.\n"
"};\n";

const char* PluginEditor_h = (const char*) temp_binary_data_32;
}
