/* ==================================== JUCER_BINARY_RESOURCE ====================================

   This is an auto-generated file: Any edits you make may be overwritten!

*/

#include <cstring>

namespace BinaryData
{

//================== PluginProcessor.cpp ==================
static const unsigned char temp_binary_data_1845[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin processor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor class.\n"
"#include \"PluginEditor.h\"    // Includes the header file for the plugin editor class.\n"
"\n"
"constexpr float BP_FREQ = 2950.0f; // Defines a constant for the band-pass filter frequency.\n"
"\n"
"//==============================================================================\n"
"// Constructor for the plugin processor class.\n"
"GramophonyAudioProcessor::GramophonyAudioProcessor()\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"    : AudioProcessor(BusesProperties() // Initializes the audio processor with bus properties.\n"
"#if ! JucePlugin_IsMidiEffect\n"
"#if ! JucePlugin_IsSynth\n"
"        .withInput(\"Input\", juce::AudioChannelSet::stereo(), true) // Adds a stereo input bus.\n"
"#endif\n"
"        .withOutput(\"Output\", juce::AudioChannelSet::stereo(), true) // Adds a stereo output bus.\n"
"#endif\n"
"    ),\n"
"    apvts(*this, nullptr, \"Parameters\", createParameters()) // Initializes the AudioProcessorValueTreeState for parameter management.\n"
"#endif\n"
"{\n"
"    // Set initial parameters (can be controlled via UI later)\n"
"    midiNoteNumber = 60.0; // Middle C\n"
"    breathPressure = 0.5;\n"
"    brassInstrument->noteOn(midiNoteNumber, breathPressure);\n"
"}\n"
"\n"
"GramophonyAudioProcessor::~GramophonyAudioProcessor()\n"
"{\n"
"    // Destructor for the plugin processor class. Cleans up resources if necessary.\n"
"\n"
"    brassInstrument->noteOff(midiNoteNumber, 0.0);\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Returns the name of the plugin.\n"
"const juce::String GramophonyAudioProcessor::getName() const\n"
"{\n"
"    return JucePlugin_Name; // Uses the name defined in the JUCE plugin configuration.\n"
"}\n"
"\n"
"// Determines if the plugin accepts MIDI input.\n"
"bool GramophonyAudioProcessor::acceptsMidi() const\n"
"{\n"
"#if JucePlugin_WantsMidiInput\n"
"    return true; // Returns true if the plugin is configured to accept MIDI input.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Determines if the plugin produces MIDI output.\n"
"bool GramophonyAudioProcessor::producesMidi() const\n"
"{\n"
"#if JucePlugin_ProducesMidiOutput\n"
"    return true; // Returns true if the plugin is configured to produce MIDI output.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Determines if the plugin is a MIDI effect.\n"
"bool GramophonyAudioProcessor::isMidiEffect() const\n"
"{\n"
"#if JucePlugin_IsMidiEffect\n"
"    return true; // Returns true if the plugin is a MIDI effect.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Returns the tail length of the plugin in seconds.\n"
"double GramophonyAudioProcessor::getTailLengthSeconds() const\n"
"{\n"
"    return 0.0; // No tail length is defined for this plugin.\n"
"}\n"
"\n"
"// Returns the number of programs (presets) available in the plugin.\n"
"int GramophonyAudioProcessor::getNumPrograms()\n"
"{\n"
"    return 1; // At least one program is required, even if not implemented.\n"
"}\n"
"\n"
"// Returns the index of the current program.\n"
"int GramophonyAudioProcessor::getCurrentProgram()\n"
"{\n"
"    return 0; // Only one program is available, so the index is always 0.\n"
"}\n"
"\n"
"// Sets the current program (not implemented in this plugin).\n"
"void GramophonyAudioProcessor::setCurrentProgram(int /*index*/)\n"
"{\n"
"}\n"
"\n"
"// Returns the name of the program at the given index (not implemented).\n"
"const juce::String GramophonyAudioProcessor::getProgramName(int /*index*/)\n"
"{\n"
"    return {}; // Returns an empty string.\n"
"}\n"
"\n"
"// Changes the name of the program at the given index (not implemented).\n"
"void GramophonyAudioProcessor::changeProgramName(int /*index*/, const juce::String& /*newName*/)\n"
"{\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Prepares the plugin for playback by initialising DSP components.\n"
"void GramophonyAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)\n"
"{\n"
"    // Initialise STK global settings (sample rate)\n"
"    stk::Stk::setSampleRate(static_cast<double>(sampleRate));\n"
"\n"
"    // Sets up the processing specification for DSP components.\n"
"    juce::dsp::ProcessSpec spec = { sampleRate, static_cast<juce::uint32>(samplesPerBlock),\n"
"                                    static_cast<juce::uint32>(getMainBusNumOutputChannels()) };\n"
"\n"
"    chorus_.prepare(spec); // Prepares the chorus effect with the processing spec.\n"
"    mix_.prepare(spec);    // Prepares the wet/dry mix processor.\n"
"\n"
"    // Retrieves the initial frequency value from the parameter tree.\n"
"    float frequency = apvts.getRawParameterValue(\"TONE\")->load();\n"
"\n"
"    // Prepares and configures the band-pass filters for each channel.\n"
"    filter_ch1_.prepare(spec);\n"
"    filter_ch1_.coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(sampleRate, frequency, 6.0f);\n"
"\n"
"    filter_ch2_.prepare(spec);\n"
"    filter_ch2_.coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(sampleRate, frequency, 6.0f);\n"
"}\n"
"\n"
"// Releases resources when playback stops.\n"
"void GramophonyAudioProcessor::releaseResources()\n"
"{\n"
"    // Frees up any resources or memory used during playback.\n"
"\n"
"    brassInstrument->noteOff(midiNoteNumber, 0.0);\n"
"}\n"
"\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"// Checks if the given bus layout is supported by the plugin.\n"
"bool GramophonyAudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const\n"
"{\n"
"#if JucePlugin_IsMidiEffect\n"
"    juce::ignoreUnused(layouts);\n"
"    return true; // MIDI effects support all layouts.\n"
"#else\n"
"    // Only mono or stereo layouts are supported.\n"
"    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()\n"
"        && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\n"
"        return false;\n"
"\n"
"    // Ensures the input layout matches the output layout for non-synth plugins.\n"
"#if ! JucePlugin_IsSynth\n"
"    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\n"
"        return false;\n"
"#endif\n"
"\n"
"    return true; // Layout is supported.\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"// Processes audio and MIDI data for each block of samples.\n"
"void GramophonyAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& /*midiMessages*/)\n"
"{\n"
"    juce::ScopedNoDenormals noDenormals; // Ensures denormalized numbers are handled correctly.\n"
"    auto totalNumInputChannels = getTotalNumInputChannels(); // Gets the number of input channels.\n"
"    auto totalNumOutputChannels = getTotalNumOutputChannels(); // Gets the number of output channels.\n"
"\n"
"    // Clears any output channels that don't have corresponding input channels.\n"
"    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)\n"
"    {\n"
"        buffer.clear(i, 0, buffer.getNumSamples());\n"
"    }\n"
"\n"
"    mix_.pushDrySamples(buffer); // Pushes the dry signal into the mix processor.\n"
"\n"
"    // Processes each sample in the buffer.\n"
"    for (int sample = 0; sample < buffer.getNumSamples(); ++sample)\n"
"    {\n"
"        for (int channel = 0; channel < totalNumInputChannels; ++channel)\n"
"        {\n"
"            float sampleValue = brassInstrument->tick();\n"
"            \n"
"            // Retrieves parameter values for compression and tone.\n"
"            float treshold = apvts.getRawParameterValue(\"COMPRESS\")->load();\n"
"            float frequency = apvts.getRawParameterValue(\"TONE\")->load();\n"
"\n"
"            // Applies compression to the signal based on the threshold.\n"
"            if (*buffer.getReadPointer(channel, sample) >= treshold)\n"
"            {\n"
"                *buffer.getWritePointer(channel, sample) = (*buffer.getReadPointer(channel, sample) / 4) + (3 * treshold / 4);\n"
"            }\n"
"            else if (*buffer.getReadPointer(channel, sample) <= -treshold)\n"
"            {\n"
"                *buffer.getWritePointer(channel, sample) = (*buffer.getReadPointer(channel, sample) / 4) - (3 * treshold / 4);\n"
"            }\n"
"\n"
"            // Applies makeup gain to the signal.\n"
"            *buffer.getWritePointer(channel, sample) *= 5.0f - (11.0f * treshold * treshold);\n"
"\n"
"            // Applies a band-pass filter to the signal for each channel.\n"
"            if (channel == 0)\n"
"            {\n"
"                filter_ch1_.coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(getSampleRate(), frequency + 10.0f, 2.7f);\n"
"                *buffer.getWritePointer(channel, sample) = filter_ch1_.processSample(*buffer.getReadPointer(channel, sample));\n"
"            }\n"
"            else if (channel == 1)\n"
"            {\n"
"                filter_ch2_.coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(getSampleRate(), frequency - 10.0f, 2.73f);\n"
"                *buffer.getWritePointer(channel, sample) = filter_ch2_.processSample(*buffer.getReadPointer(channel, sample));\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Wraps the buffer in an AudioBlock for further processing.\n"
"    auto block = juce::dsp::AudioBlock<float>(buffer);\n"
"    auto contextToUse = juce::dsp::ProcessContextReplacing<float>(block);\n"
"\n"
"    // Configures and processes the chorus effect.\n"
"    chorus_.setRate(apvts.getRawParameterValue(\"VIBRATO_RATE\")->load());\n"
"    chorus_.setDepth(apvts.getRawParameterValue(\"VIBRATO\")->load());\n"
"    chorus_.setCentreDelay(1.0f);\n"
"    chorus_.setFeedback(0.0f);\n"
"    chorus_.setMix(1.0f);\n"
"    chorus_.process(contextToUse);\n"
"\n"
"    // Configures and applies the wet/dry mix.\n"
"    mix_.setWetMixProportion(1.0f - apvts.getRawParameterValue(\"MIX\")->load());\n"
"    mix_.mixWetSamples(block);\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Indicates whether the plugin has an editor.\n"
"bool GramophonyAudioProcessor::hasEditor() const\n"
"{\n"
"    return true; // Returns true to indicate the plugin has a GUI editor.\n"
"}\n"
"\n"
"// Creates and returns the plugin editor.\n"
"juce::AudioProcessorEditor* GramophonyAudioProcessor::createEditor()\n"
"{\n"
"    return new GramophonyAudioProcessorEditor(*this); // Creates an instance of the editor.\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Saves the plugin's state to a memory block.\n"
"void GramophonyAudioProcessor::getStateInformation(juce::MemoryBlock& destData)\n"
"{\n"
"    auto state = apvts.copyState(); // Copies the current state of the parameters.\n"
"    std::unique_ptr<juce::XmlElement> xml(state.createXml()); // Converts the state to XML.\n"
"    copyXmlToBinary(*xml, destData); // Saves the XML to the memory block.\n"
"}\n"
"\n"
"// Restores the plugin's state from a memory block.\n"
"void GramophonyAudioProcessor::setStateInformation(const void* data, int sizeInBytes)\n"
"{\n"
"    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes)); // Reads XML from the memory block.\n"
"\n"
"    if (xmlState.get() != nullptr)\n"
"        if (xmlState->hasTagName(apvts.state.getType())) // Checks if the XML tag matches the parameter tree type.\n"
"            apvts.replaceState(juce::ValueTree::fromXml(*xmlState)); // Restores the state from the XML.\n"
"}\n"
"\n"
"// Creates and returns the parameter layout for the plugin.\n"
"juce::AudioProcessorValueTreeState::ParameterLayout GramophonyAudioProcessor::createParameters()\n"
"{\n"
"    std::vector<std::unique_ptr<juce::RangedAudioParameter>> parameters; // Stores the parameters.\n"
"\n"
"    // Adds parameters for compression, vibrato, tone, and mix.\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"COMPRESS\", \"Compress\", 0.04f, 0.45f, 0.1f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"VIBRATO\", \"Vibrato\", 0.0f, 0.33f, 0.01f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"VIBRATO_RATE\", \"Rate\", 0.5f, 4.0f, 2.0f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"TONE\", \"Tone\", 320.1f, 4700.0f, 2000.0f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"MIX\", \"Mix\", 0.0f, 0.5f, 0.0f));\n"
"    return { parameters.begin(), parameters.end() }; // Returns the parameter layout.\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Factory function to create a new instance of the plugin.\n"
"juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()\n"
"{\n"
"    return new GramophonyAudioProcessor(); // Creates and returns a new instance of the processor.\n"
"}\n";

const char* PluginProcessor_cpp = (const char*) temp_binary_data_1845;

//================== PluginProcessor.h ==================
static const unsigned char temp_binary_data_1846[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin processor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#pragma once // Ensures the file is included only once during compilation.\n"
"\n"
"#include <JuceHeader.h> // Includes the JUCE framework header file.\n"
"#include <stk/Brass.h> // Includes the STK Brass instrument header file.\n"
"\n"
"//==============================================================================\n"
"/**\n"
" * The main audio processor class for the plugin.\n"
" * Inherits from juce::AudioProcessor and implements its virtual methods.\n"
" */\n"
"class GramophonyAudioProcessor : public juce::AudioProcessor\n"
"{\n"
"public:\n"
"\n"
"    //==============================================================================\n"
"    GramophonyAudioProcessor(); // Constructor for the audio processor.\n"
"    ~GramophonyAudioProcessor() override; // Destructor for the audio processor.\n"
"\n"
"    //==============================================================================\n"
"    void prepareToPlay(double sampleRate, int samplesPerBlock) override; // Prepares the processor for playback by initialising resources\n"
"    \n"
"    void releaseResources() override; // Releases resources when playback stops.\n"
"\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"    bool isBusesLayoutSupported(const BusesLayout& layouts) const override; // Checks if the given bus layout is supported by the plugin\n"
"#endif\n"
"    \n"
"    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override; // Processes audio and MIDI data for each block of samples\n"
"\n"
"    //==============================================================================\n"
"    juce::AudioProcessorEditor* createEditor() override; // Creates and returns the plugin editor (GUI)\n"
"\n"
"    bool hasEditor() const override; // Indicates whether the plugin has an editor (GUI)\n"
"\n"
"    //==============================================================================\n"
"    const juce::String getName() const override; // Returns the name of the plugin\n"
"    \n"
"    bool acceptsMidi() const override; // Determines if the plugin accepts MIDI input\n"
"\tbool producesMidi() const override; // Determines if the plugin produces MIDI output\n"
"    bool isMidiEffect() const override; // Determines if the plugin is a MIDI effect\n"
"\n"
"    double getTailLengthSeconds() const override; // Returns the tail length of the plugin in seconds\n"
"\n"
"    //==============================================================================\n"
"    int getNumPrograms() override; // Returns the number of programs (presets) available in the plugin\n"
"    int getCurrentProgram() override; // Returns the index of the current program\n"
"    void setCurrentProgram(int index) override; // Sets the current program (preset) by index.\n"
"\n"
"    const juce::String getProgramName(int index) override; // Returns the name of the program (preset) at the given index\n"
"    void changeProgramName(int index, const juce::String& newName) override; // Changes the name of the program (preset) at the given index\n"
"\n"
"    //==============================================================================\n"
"    void getStateInformation(juce::MemoryBlock& destData) override; // Saves the plugin's state to a memory block\n"
"\n"
"    void setStateInformation(const void* data, int sizeInBytes) override; // Restores the plugin's state from a memory block\n"
"\n"
"    juce::AudioProcessorValueTreeState apvts; // Manages the plugin's parameters using a value tree state.\n"
"\n"
"private:\n"
"\n"
"\t//==============================================================================\n"
"    // Creates and returns the parameter layout for the plugin.\n"
"    juce::AudioProcessorValueTreeState::ParameterLayout createParameters();\n"
"\n"
"    // DSP components used in the plugin.\n"
"    juce::dsp::Chorus<float> chorus_; // Chorus effect processor.\n"
"    juce::dsp::IIR::Filter<float> filter_ch1_; // Band-pass filter for channel 1.\n"
"    juce::dsp::IIR::Filter<float> filter_ch2_; // Band-pass filter for channel 2.\n"
"    juce::dsp::DryWetMixer<float> mix_; // Wet/dry mix processor.\n"
"\n"
"    //==============================================================================\n"
"    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(GramophonyAudioProcessor)\n"
"        // Macro to prevent copying and enable leak detection for the class.\n"
"};";

const char* PluginProcessor_h = (const char*) temp_binary_data_1846;

//================== PluginEditor.cpp ==================
static const unsigned char temp_binary_data_1847[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin editor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#include \"PluginEditor.h\" // Includes the header file for the plugin editor.\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor.\n"
"\n"
"\n"
"constexpr float LINE_THICKNESS = 4.0f; // Defines the thickness of lines drawn in the editor.\n"
"\n"
"//==============================================================================\n"
"// Constructor for the plugin editor.\n"
"GramophonyAudioProcessorEditor::GramophonyAudioProcessorEditor(GramophonyAudioProcessor& p)\n"
"    : AudioProcessorEditor(&p), // Initialises the base class with the processor reference.\n"
"    audioProcessor(p), // Stores a reference to the audio processor.\n"
"    info_button_(juce::Colours::darkgrey), // Initialises the info button with a dark gray colour.\n"
"\topenGLContext_(*this) // Sets up the OpenGL context for rendering.\n"
"{\n"
"    constexpr int TEXT_BOX_SIZE = 25; // Defines the size of the text box for sliders.\n"
"\n"
"    // Sets up the compression slider.\n"
"    compress_slider_.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag); // Rotary slider style.\n"
"    compress_slider_.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE); // No text box for the slider.\n"
"    compress_slider_.addListener(this); // Adds this editor as a listener for slider changes.\n"
"    addAndMakeVisible(compress_slider_); // Makes the slider visible in the editor.\n"
"\n"
"    // Links the compression slider to the \"COMPRESS\" parameter in the processor's parameter tree.\n"
"    compress_slider_attachment_ = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"COMPRESS\", compress_slider_);\n"
"\n"
"    // Sets up the tone slider.\n"
"    tone_slider_.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    tone_slider_.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    tone_slider_.addListener(this);\n"
"    addAndMakeVisible(tone_slider_);\n"
"    tone_slider_attachment_ = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"TONE\", tone_slider_);\n"
"\n"
"    // Sets up the vibrato slider.\n"
"    vibrato_slider_.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    vibrato_slider_.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    vibrato_slider_.addListener(this);\n"
"    addAndMakeVisible(vibrato_slider_);\n"
"    vibrato_slider_attachment_ = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"VIBRATO\", vibrato_slider_);\n"
"\n"
"    // Sets up the vibrato rate slider.\n"
"    vibrato_rate_slider_.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    vibrato_rate_slider_.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    vibrato_rate_slider_.addListener(this);\n"
"    addAndMakeVisible(vibrato_rate_slider_);\n"
"    vibrato_rate_slider_attachment_ = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"VIBRATO_RATE\", vibrato_rate_slider_);\n"
"\n"
"    // Sets up the mix slider.\n"
"    mix_slider_.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    mix_slider_.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    mix_slider_.addListener(this);\n"
"    addAndMakeVisible(mix_slider_);\n"
"    mix_slider_attachment_ = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"MIX\", mix_slider_);\n"
"\n"
"    // Adds the info button to the editor.\n"
"    info_button_.addToEditor(this);\n"
"\n"
"    // Attach and initialise OpenGL\n"
"    openGLContext.setRenderer(this);\n"
"    openGLContext.attachTo(*this);\n"
"\n"
"    setSize(500, 300); // Sets the initial size of the editor window.\n"
"}\n"
"\n"
"// Destructor for the plugin editor.\n"
"GramophonyAudioProcessorEditor::~GramophonyAudioProcessorEditor()\n"
"{\n"
"    openGLContext.detach();\n"
"    if (vertexBuffer != 0)\n"
"        openGLContext.extensions.glDeleteBuffers(1, &vertexBuffer);\n"
"    if (shaderProgram != 0)\n"
"    {\n"
"        GLuint shaders[2];\n"
"        openGLContext.extensions.glGetAttachedShaders(shaderProgram, shaders);\n"
"        for (auto shader : shaders)\n"
"            openGLContext.extensions.glDeleteShader(shader);\n"
"        openGLContext.extensions.glDeleteProgram(shaderProgram);\n"
"    }\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Paints the editor's GUI components.\n"
"void GramophonyAudioProcessorEditor::paint(juce::Graphics& g)\n"
"{\n"
"    g.fillAll(juce::Colours::beige); // Fills the background with a beige color.\n"
"\n"
"    g.setColour(juce::Colour(0xff123456)); // Sets the color for the title text.\n"
"    g.setFont(40.0f); // Sets the font size for the title text.\n"
"    g.drawFittedText(\"GRAMOPHONY\", getLocalBounds(), juce::Justification::centredTop, 1); // Draws the plugin title.\n"
"\n"
"    assimp::Importer::ReadFile\n"
"\n"
"    objParser.load(gramoSuite.getFullPathName()); // Use getFullPathName()\n"
"\n"
"    SetupSections(); // Sets up the layout sections for the GUI.\n"
"\n"
"    // Draws labels for the sliders.\n"
"    g.setFont(18.0f);\n"
"    g.drawFittedText(\"COMP\", comp_text_section_, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"TONE\", tone_text_section_, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"VIBE\", vibrato_text_section_, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"DRY\", mix_text_section_, juce::Justification::left, 1);\n"
"}\n"
"\n"
"// Converts a slider's value to an alpha (transparency) value.\n"
"float GramophonyAudioProcessorEditor::sliderToAplhaValue(juce::Slider& slider)\n"
"{\n"
"    double range = (slider.getMaximum() - slider.getMinimum());\n"
"    return static_cast<float>((slider.getValue() - slider.getMinimum()) / range);\n"
"}\n"
"\n"
"// Draws a line connecting three points.\n"
"void GramophonyAudioProcessorEditor::DrawThreePointLine(juce::Graphics& g,\n"
"    float x1,\n"
"    float y1,\n"
"    float x2,\n"
"    float y2,\n"
"    float x3,\n"
"    float y3)\n"
"{\n"
"    g.drawLine(juce::Line<float>(x1, y1, x2, y2), LINE_THICKNESS);\n"
"    g.drawLine(juce::Line<float>(x2, y2, x3, y3), LINE_THICKNESS);\n"
"}\n"
"\n"
"// Handles resizing and layout of GUI components.\n"
"void GramophonyAudioProcessorEditor::resized()\n"
"{\n"
"    info_button_.button.setBounds(getWidth() - 35, 10, 20, 20); // Positions the info button.\n"
"    info_button_.info_text.setBounds(30, 50, getWidth() - 60, getHeight() - 100); // Positions the info text.\n"
"    SetupSections(); // Updates the layout sections.\n"
"    compress_slider_.setBounds(comp_section_); // Positions the compression slider.\n"
"    tone_slider_.setBounds(tone_section_); // Positions the tone slider.\n"
"    vibrato_slider_.setBounds(vibrato_section_); // Positions the vibrato slider.\n"
"    vibrato_rate_slider_.setBounds(vibrato_rate_section_); // Positions the vibrato rate slider.\n"
"    mix_slider_.setBounds(mix_section_); // Positions the mix slider.\n"
"}\n"
"\n"
"// Sets up the layout sections for the GUI.\n"
"void GramophonyAudioProcessorEditor::SetupSections()\n"
"{\n"
"    juce::Rectangle<int> r = getLocalBounds(); // Gets the bounds of the editor.\n"
"    top_section_ = r.removeFromTop(50); // Allocates the top section.\n"
"    picture_section_ = r.removeFromLeft(310); // Allocates the picture section.\n"
"\n"
"    juce::Rectangle<int> interface_section = r; // Remaining area for the interface.\n"
"    int section_height = interface_section.getHeight() / 4; // Divides the interface into four sections.\n"
"    constexpr int text_section_width = 40; // Width for the text labels.\n"
"\n"
"    // Allocates sections for sliders and their labels.\n"
"    comp_section_ = interface_section.removeFromTop(section_height);\n"
"    comp_text_section_ = comp_section_.removeFromLeft(text_section_width);\n"
"\n"
"    tone_section_ = interface_section.removeFromTop(section_height);\n"
"    tone_text_section_ = tone_section_.removeFromLeft(text_section_width);\n"
"\n"
"    vibrato_section_ = interface_section.removeFromTop(section_height);\n"
"    vibrato_text_section_ = vibrato_section_.removeFromLeft(text_section_width);\n"
"    vibrato_rate_section_ = vibrato_section_.removeFromRight(vibrato_section_.getWidth() / 2);\n"
"\n"
"    mix_section_ = interface_section;\n"
"    mix_text_section_ = mix_section_.removeFromLeft(text_section_width);\n"
"}\n"
"\n"
"// Callback for when a slider's value changes.\n"
"void GramophonyAudioProcessorEditor::sliderValueChanged(juce::Slider* /*slider*/)\n"
"{\n"
"    repaint(); // Repaints the editor to reflect the updated slider value.\n"
"}\n";

const char* PluginEditor_cpp = (const char*) temp_binary_data_1847;

//================== PluginEditor.h ==================
static const unsigned char temp_binary_data_1848[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin editor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#pragma once // Ensures the file is included only once during compilation.\n"
"\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor.\n"
"#include \"InfoButton.h\"      // Includes the header file for the InfoButton class.\n"
"#include <JuceHeader.h>      // Includes the JUCE framework header file.\n"
"\n"
"#include <../Source/assimp/include/assimp/Importer.hpp> //C++ importer interface\n"
"#include <../Source/assimp/include/assimp/scene.h> // Output data structure\n"
"#include <../Source/assimp/include/assimp/postprocess.h> // Post processing flags\n"
"\n"
"\n"
"//==============================================================================\n"
"/**\n"
" * The main editor class for the plugin.\n"
" * Inherits from juce::AudioProcessorEditor and juce::Slider::Listener.\n"
" * Handles the GUI and user interactions for the plugin.\n"
" */\n"
"class GramophonyAudioProcessorEditor : public juce::AudioProcessorEditor,\n"
"\tpublic juce::Slider::Listener, public juce::Open\n"
"{\n"
"public:\n"
"    explicit GramophonyAudioProcessorEditor(GramophonyAudioProcessor&); // Constructor that takes a reference to the audio processor.\n"
"    ~GramophonyAudioProcessorEditor() override; // Destructor for the editor.\n"
"\n"
"    //==============================================================================\n"
"    void paint(juce::Graphics&) override; // Paints the editor's GUI components.\n"
"    void DrawThreePointLine(juce::Graphics&, float x1, float y1, float x2, float y2, float x3, float y3); // Custom method to draw a line connecting three points.\n"
"    void resized() override; // Handles resizing and layout of GUI components.\n"
"\n"
"private:\n"
"    float sliderToAplhaValue(juce::Slider& slider); // Converts a slider's value to an alpha (transparency) value.\n"
"    void SetupSections(); // Sets up the layout and sections of the GUI.\n"
"    void sliderValueChanged(juce::Slider* slider) override; // Callback for when a slider's value changes.\n"
"\n"
"    InfoButton info_button_; // Custom button for displaying information about the plugin.\n"
"\n"
"    // Type alias for a unique pointer to a SliderAttachment.\n"
"    typedef std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> SliderAttatchmentPtr;\n"
"\n"
"    // Sliders for controlling various parameters of the plugin.\n"
"    juce::Slider compress_slider_; // Slider for controlling the compression parameter.\n"
"    SliderAttatchmentPtr compress_slider_attachment_; // Attachment to link the compress slider to the parameter tree.\n"
"\n"
"    juce::Slider tone_slider_; // Slider for controlling the tone parameter.\n"
"    SliderAttatchmentPtr tone_slider_attachment_; // Attachment to link the tone slider to the parameter tree.\n"
"\n"
"    juce::Slider vibrato_slider_; // Slider for controlling the vibrato depth parameter.\n"
"    SliderAttatchmentPtr vibrato_slider_attachment_; // Attachment to link the vibrato slider to the parameter tree.\n"
"\n"
"    juce::Slider vibratoRate; // Slider for controlling the vibrato rate parameter.\n"
"    SliderAttatchmentPtr vibrato_rate_slider_attachment_; // Attachment to link the vibrato rate slider to the parameter tree.\n"
"\n"
"    juce::Slider mix_slider_; // Slider for controlling the wet/dry mix parameter.\n"
"    SliderAttatchmentPtr mix_slider_attachment_; // Attachment to link the mix slider to the parameter tree.\n"
"\n"
"    // Rectangles defining sections of the GUI layout.\n"
"    juce::Rectangle<int> top_section_; // Rectangle for the top section of the GUI.\n"
"    juce::Rectangle<int> picture_section_; // Rectangle for the picture section of the GUI.\n"
"    juce::Rectangle<int> comp_section_; // Rectangle for the compression slider section.\n"
"    juce::Rectangle<int> tone_section_; // Rectangle for the tone slider section.\n"
"    juce::Rectangle<int> vibrato_section_; // Rectangle for the vibrato slider section.\n"
"    juce::Rectangle<int> vibrato_rate_section_; // Rectangle for the vibrato rate slider section.\n"
"    juce::Rectangle<int> mix_section_; // Rectangle for the mix slider section.\n"
"    juce::Rectangle<int> comp_text_section_; // Rectangle for the compression text label section.\n"
"    juce::Rectangle<int> tone_text_section_; // Rectangle for the tone text label section.\n"
"    juce::Rectangle<int> vibrato_text_section_; // Rectangle for the vibrato text label section.\n"
"    juce::Rectangle<int> mix_text_section_; // Rectangle for the mix text label section.\n"
"\n"
"\tAssimp::Importer importer; // Assimp importer for loading 3D models.\n"
"\n"
"    // OpenGL-related members\n"
"    juce::OpenGLContext openGLContext;\n"
"    GLuint vertexBuffer = 0;\n"
"    GLuint shaderProgram = 0;\n"
"\n"
"    GramophonyAudioProcessor& audioProcessor; // Reference to the audio processor instance.\n"
"\n"
"    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(GramophonyAudioProcessorEditor)\n"
"        // Macro to prevent copying and enable leak detection for the class.\n"
"};\n";

const char* PluginEditor_h = (const char*) temp_binary_data_1848;

//================== InfoButton.cpp ==================
static const unsigned char temp_binary_data_1849[] =
"#include \"InfoButton.h\"\n"
"\n"
"InfoButton::InfoButton (juce::Colour colour)\n"
"{\n"
"    button.setButtonText (\"i\");\n"
"    button.addListener (this);\n"
"\n"
"    info_text.setColour (juce::Label::backgroundColourId, colour);\n"
"    info_text.setColour (juce::Label::outlineColourId, juce::Colours::white);\n"
"    info_text.setColour (juce::Label::textColourId, juce::Colours::lightgrey);\n"
"    info_text.setJustificationType (juce::Justification::centredLeft);\n"
"    info_text.setBorderSize (juce::BorderSize<int> (20, 70, 20, 70));\n"
"\n"
"    std::string info_string = \"\";\n"
"    info_string += ProjectInfo::companyName + std::string (\" \") + ProjectInfo::projectName + std::string (\" version \") + ProjectInfo::versionString + std::string (\"\\n\\n\");\n"
"    info_string += std::string (\"by Montague Whishaw\\n\\n\");\n"
"    info_string += std::string (\"Check out my other projects at https://github.com/MontagueWh\");\n"
"\n"
"    info_text.setText (info_string, juce::dontSendNotification);\n"
"}\n"
"\n"
"InfoButton::~InfoButton() {}\n"
"\n"
"void InfoButton::addToEditor (juce::AudioProcessorEditor* editor)\n"
"{\n"
"    editor->addAndMakeVisible (info_text);\n"
"    info_text.setVisible (false);\n"
"    editor->addAndMakeVisible (button);\n"
"}\n"
"\n"
"void InfoButton::buttonStateChanged (juce::Button* b)\n"
"{\n"
"    if (b == &button)\n"
"    {\n"
"        if (button.isOver())\n"
"        {\n"
"            info_text.setVisible (true);\n"
"        }\n"
"        else\n"
"        {\n"
"            info_text.setVisible (false);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"void InfoButton::buttonClicked (juce::Button* button)\n"
"{\n"
"}\n";

const char* InfoButton_cpp = (const char*) temp_binary_data_1849;

//================== InfoButton.h ==================
static const unsigned char temp_binary_data_1850[] =
"#pragma once\n"
"\n"
"#include <JuceHeader.h>\n"
"\n"
"// Use the info button class by\n"
"// 1) Create an InfoButton object\n"
"// 2) Make the button visible by  using the function addToEditor(this) from PluginEditor class\n"
"// 3) In resized() function set boundry of the public data members button and info_text\n"
"class InfoButton : public juce::Button::Listener\n"
"{\n"
"public:\n"
"    explicit InfoButton (juce::Colour colour);\n"
"    ~InfoButton();\n"
"    void addToEditor (juce::AudioProcessorEditor* editor);\n"
"    void buttonStateChanged (juce::Button* b) override;\n"
"    void buttonClicked (juce::Button* button) override;\n"
"    juce::TextButton button;\n"
"    juce::Label info_text;\n"
"};\n";

const char* InfoButton_h = (const char*) temp_binary_data_1850;
}
