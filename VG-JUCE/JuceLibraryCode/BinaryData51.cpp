/* ==================================== JUCER_BINARY_RESOURCE ====================================

   This is an auto-generated file: Any edits you make may be overwritten!

*/

#include <cstring>

namespace BinaryData
{

//================== PluginProcessor.cpp ==================
static const unsigned char temp_binary_data_1936[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin processor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor class.\n"
"#include \"PluginEditor.h\"    // Includes the header file for the plugin editor class.\n"
"\n"
"constexpr float BP_FREQ = 2950.0f; // Defines a constant for the band-pass filter frequency.\n"
"\n"
"//==============================================================================\n"
"// Constructor for the plugin processor class.\n"
"VirtualGramoAudioProcessor::VirtualGramoAudioProcessor()\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"    : AudioProcessor(BusesProperties() // Initializes the audio processor with bus properties.\n"
"#if ! JucePlugin_IsMidiEffect\n"
"#if ! JucePlugin_IsSynth\n"
"        .withInput(\"Input\", juce::AudioChannelSet::stereo(), true) // Adds a stereo input bus.\n"
"#endif\n"
"        .withOutput(\"Output\", juce::AudioChannelSet::stereo(), true) // Adds a stereo output bus.\n"
"#endif\n"
"    ),\n"
"    apvts(*this, nullptr, \"Parameters\", createParameters()) // Initializes the AudioProcessorValueTreeState for parameter management.\n"
"#endif\n"
"{\n"
"}\n"
"\n"
"VirtualGramoAudioProcessor::~VirtualGramoAudioProcessor()\n"
"{\n"
"    // Destructor for the plugin processor class. Cleans up resources if necessary.\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Returns the name of the plugin.\n"
"const juce::String VirtualGramoAudioProcessor::getName() const\n"
"{\n"
"    return JucePlugin_Name; // Uses the name defined in the JUCE plugin configuration.\n"
"}\n"
"\n"
"// Determines if the plugin accepts MIDI input.\n"
"bool VirtualGramoAudioProcessor::acceptsMidi() const\n"
"{\n"
"#if JucePlugin_WantsMidiInput\n"
"    return true; // Returns true if the plugin is configured to accept MIDI input.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Determines if the plugin produces MIDI output.\n"
"bool VirtualGramoAudioProcessor::producesMidi() const\n"
"{\n"
"#if JucePlugin_ProducesMidiOutput\n"
"    return true; // Returns true if the plugin is configured to produce MIDI output.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Determines if the plugin is a MIDI effect.\n"
"bool VirtualGramoAudioProcessor::isMidiEffect() const\n"
"{\n"
"#if JucePlugin_IsMidiEffect\n"
"    return true; // Returns true if the plugin is a MIDI effect.\n"
"#else\n"
"    return false; // Returns false otherwise.\n"
"#endif\n"
"}\n"
"\n"
"// Returns the tail length of the plugin in seconds.\n"
"double VirtualGramoAudioProcessor::getTailLengthSeconds() const\n"
"{\n"
"    return 0.0; // No tail length is defined for this plugin.\n"
"}\n"
"\n"
"// Returns the number of programs (presets) available in the plugin.\n"
"int VirtualGramoAudioProcessor::getNumPrograms()\n"
"{\n"
"    return 1; // At least one program is required, even if not implemented.\n"
"}\n"
"\n"
"// Returns the index of the current program.\n"
"int VirtualGramoAudioProcessor::getCurrentProgram()\n"
"{\n"
"    return 0; // Only one program is available, so the index is always 0.\n"
"}\n"
"\n"
"// Sets the current program (not implemented in this plugin).\n"
"void VirtualGramoAudioProcessor::setCurrentProgram(int /*index*/)\n"
"{\n"
"}\n"
"\n"
"// Returns the name of the program at the given index (not implemented).\n"
"const juce::String VirtualGramoAudioProcessor::getProgramName(int /*index*/)\n"
"{\n"
"    return {}; // Returns an empty string.\n"
"}\n"
"\n"
"// Changes the name of the program at the given index (not implemented).\n"
"void VirtualGramoAudioProcessor::changeProgramName(int /*index*/, const juce::String& /*newName*/)\n"
"{\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Prepares the plugin for playback by initialising DSP components.\n"
"void VirtualGramoAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)\n"
"{\n"
"    // Sets up the processing specification for DSP components.\n"
"    juce::dsp::ProcessSpec spec = { sampleRate, static_cast<juce::uint32>(samplesPerBlock),\n"
"                                    static_cast<juce::uint32>(getMainBusNumOutputChannels()) };\n"
"\n"
"    chorus_.prepare(spec); // Prepares the chorus effect with the processing spec.\n"
"    mix_.prepare(spec);    // Prepares the wet/dry mix processor.\n"
"\n"
"    // Retrieves the initial frequency value from the parameter tree.\n"
"    float frequency = apvts.getRawParameterValue(\"TONE\")->load();\n"
"\n"
"    // Prepares and configures the band-pass filters for each channel.\n"
"    filter_ch1_.prepare(spec);\n"
"    filter_ch1_.coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(sampleRate, frequency, 6.0f);\n"
"\n"
"    filter_ch2_.prepare(spec);\n"
"    filter_ch2_.coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(sampleRate, frequency, 6.0f);\n"
"}\n"
"\n"
"// Releases resources when playback stops.\n"
"void VirtualGramoAudioProcessor::releaseResources()\n"
"{\n"
"    // Frees up any resources or memory used during playback.\n"
"\n"
"    \n"
"}\n"
"\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"// Checks if the given bus layout is supported by the plugin.\n"
"bool VirtualGramoAudioProcessor::isBusesLayoutSupported(const BusesLayout& layouts) const\n"
"{\n"
"#if JucePlugin_IsMidiEffect\n"
"    juce::ignoreUnused(layouts);\n"
"    return true; // MIDI effects support all layouts.\n"
"#else\n"
"    // Only mono or stereo layouts are supported.\n"
"    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()\n"
"        && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())\n"
"        return false;\n"
"\n"
"    // Ensures the input layout matches the output layout for non-synth plugins.\n"
"#if ! JucePlugin_IsSynth\n"
"    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())\n"
"        return false;\n"
"#endif\n"
"\n"
"    return true; // Layout is supported.\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"// Processes audio and MIDI data for each block of samples.\n"
"void VirtualGramoAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& /*midiMessages*/)\n"
"{\n"
"    juce::ScopedNoDenormals noDenormals; // Ensures denormalized numbers are handled correctly.\n"
"    auto totalNumInputChannels = getTotalNumInputChannels(); // Gets the number of input channels.\n"
"    auto totalNumOutputChannels = getTotalNumOutputChannels(); // Gets the number of output channels.\n"
"\n"
"    // Clears any output channels that don't have corresponding input channels.\n"
"    for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)\n"
"    {\n"
"        buffer.clear(i, 0, buffer.getNumSamples());\n"
"    }\n"
"\n"
"    mix_.pushDrySamples(buffer); // Pushes the dry signal into the mix processor.\n"
"\n"
"    // Processes each sample in the buffer.\n"
"    for (int sample = 0; sample < buffer.getNumSamples(); ++sample)\n"
"    {\n"
"        for (int channel = 0; channel < totalNumInputChannels; ++channel)\n"
"        {            \n"
"            // Retrieves parameter values for compression and tone.\n"
"            float treshold = apvts.getRawParameterValue(\"COMPRESS\")->load();\n"
"            float frequency = apvts.getRawParameterValue(\"TONE\")->load();\n"
"\n"
"            // Applies compression to the signal based on the threshold.\n"
"            if (*buffer.getReadPointer(channel, sample) >= treshold)\n"
"            {\n"
"                *buffer.getWritePointer(channel, sample) = (*buffer.getReadPointer(channel, sample) / 4) + (3 * treshold / 4);\n"
"            }\n"
"            else if (*buffer.getReadPointer(channel, sample) <= -treshold)\n"
"            {\n"
"                *buffer.getWritePointer(channel, sample) = (*buffer.getReadPointer(channel, sample) / 4) - (3 * treshold / 4);\n"
"            }\n"
"\n"
"            // Applies makeup gain to the signal.\n"
"            *buffer.getWritePointer(channel, sample) *= 5.0f - (11.0f * treshold * treshold);\n"
"\n"
"            // Applies a band-pass filter to the signal for each channel.\n"
"            if (channel == 0)\n"
"            {\n"
"                filter_ch1_.coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(getSampleRate(), frequency + 10.0f, 2.7f);\n"
"                *buffer.getWritePointer(channel, sample) = filter_ch1_.processSample(*buffer.getReadPointer(channel, sample));\n"
"            }\n"
"            else if (channel == 1)\n"
"            {\n"
"                filter_ch2_.coefficients = juce::dsp::IIR::Coefficients<float>::makeBandPass(getSampleRate(), frequency - 10.0f, 2.73f);\n"
"                *buffer.getWritePointer(channel, sample) = filter_ch2_.processSample(*buffer.getReadPointer(channel, sample));\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Wraps the buffer in an AudioBlock for further processing.\n"
"    auto block = juce::dsp::AudioBlock<float>(buffer);\n"
"    auto contextToUse = juce::dsp::ProcessContextReplacing<float>(block);\n"
"\n"
"    // Configures and processes the chorus effect.\n"
"    chorus_.setRate(apvts.getRawParameterValue(\"VIBRATO_RATE\")->load());\n"
"    chorus_.setDepth(apvts.getRawParameterValue(\"VIBRATO\")->load());\n"
"    chorus_.setCentreDelay(1.0f);\n"
"    chorus_.setFeedback(0.0f);\n"
"    chorus_.setMix(1.0f);\n"
"    chorus_.process(contextToUse);\n"
"\n"
"    // Configures and applies the wet/dry mix.\n"
"    mix_.setWetMixProportion(1.0f - apvts.getRawParameterValue(\"MIX\")->load());\n"
"    mix_.mixWetSamples(block);\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Indicates whether the plugin has an editor.\n"
"bool VirtualGramoAudioProcessor::hasEditor() const\n"
"{\n"
"    return true; // Returns true to indicate the plugin has a GUI editor.\n"
"}\n"
"\n"
"// Creates and returns the plugin editor.\n"
"juce::AudioProcessorEditor* VirtualGramoAudioProcessor::createEditor()\n"
"{\n"
"    return new VirtualGramoAudioProcessorEditor(*this); // Creates an instance of the editor.\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Saves the plugin's state to a memory block.\n"
"void VirtualGramoAudioProcessor::getStateInformation(juce::MemoryBlock& destData)\n"
"{\n"
"    auto state = apvts.copyState(); // Copies the current state of the parameters.\n"
"    std::unique_ptr<juce::XmlElement> xml(state.createXml()); // Converts the state to XML.\n"
"    copyXmlToBinary(*xml, destData); // Saves the XML to the memory block.\n"
"}\n"
"\n"
"// Restores the plugin's state from a memory block.\n"
"void VirtualGramoAudioProcessor::setStateInformation(const void* data, int sizeInBytes)\n"
"{\n"
"    std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes)); // Reads XML from the memory block.\n"
"\n"
"    if (xmlState.get() != nullptr)\n"
"        if (xmlState->hasTagName(apvts.state.getType())) // Checks if the XML tag matches the parameter tree type.\n"
"            apvts.replaceState(juce::ValueTree::fromXml(*xmlState)); // Restores the state from the XML.\n"
"}\n"
"\n"
"// Creates and returns the parameter layout for the plugin.\n"
"juce::AudioProcessorValueTreeState::ParameterLayout VirtualGramoAudioProcessor::createParameters()\n"
"{\n"
"    std::vector<std::unique_ptr<juce::RangedAudioParameter>> parameters; // Stores the parameters.\n"
"\n"
"    // Adds parameters for compression, vibrato, tone, and mix.\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"COMPRESS\", \"Compress\", 0.04f, 0.45f, 0.1f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"VIBRATO\", \"Vibrato\", 0.0f, 0.33f, 0.01f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"VIBRATO_RATE\", \"Rate\", 0.5f, 4.0f, 2.0f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"TONE\", \"Tone\", 320.1f, 4700.0f, 2000.0f));\n"
"    parameters.push_back(std::make_unique<juce::AudioParameterFloat>(\"MIX\", \"Mix\", 0.0f, 0.5f, 0.0f));\n"
"    return { parameters.begin(), parameters.end() }; // Returns the parameter layout.\n"
"}\n"
"\n"
"//==============================================================================\n"
"// Factory function to create a new instance of the plugin.\n"
"juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()\n"
"{\n"
"    return new VirtualGramoAudioProcessor(); // Creates and returns a new instance of the processor.\n"
"}\n";

const char* PluginProcessor_cpp = (const char*) temp_binary_data_1936;

//================== PluginProcessor.h ==================
static const unsigned char temp_binary_data_1937[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin processor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#pragma once // Ensures the file is included only once during compilation.\n"
"\n"
"#include <JuceHeader.h> // Includes the JUCE framework header file.\n"
"// #include <stk/Brass.h> // Includes the STK Brass instrument header file.\n"
"\n"
"//==============================================================================\n"
"/**\n"
" * The main audio processor class for the plugin.\n"
" * Inherits from juce::AudioProcessor and implements its virtual methods.\n"
" */\n"
"class VirtualGramoAudioProcessor : public juce::AudioProcessor\n"
"{\n"
"public:\n"
"\n"
"    //==============================================================================\n"
"    VirtualGramoAudioProcessor(); // Constructor for the audio processor.\n"
"    ~VirtualGramoAudioProcessor() override; // Destructor for the audio processor.\n"
"\n"
"    //==============================================================================\n"
"    void prepareToPlay(double sampleRate, int samplesPerBlock) override; // Prepares the processor for playback by initialising resources\n"
"    \n"
"    void releaseResources() override; // Releases resources when playback stops.\n"
"\n"
"#ifndef JucePlugin_PreferredChannelConfigurations\n"
"    bool isBusesLayoutSupported(const BusesLayout& layouts) const override; // Checks if the given bus layout is supported by the plugin\n"
"#endif\n"
"    \n"
"    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override; // Processes audio and MIDI data for each block of samples\n"
"\n"
"    //==============================================================================\n"
"    juce::AudioProcessorEditor* createEditor() override; // Creates and returns the plugin editor (GUI)\n"
"\n"
"    bool hasEditor() const override; // Indicates whether the plugin has an editor (GUI)\n"
"\n"
"    //==============================================================================\n"
"    const juce::String getName() const override; // Returns the name of the plugin\n"
"    \n"
"    bool acceptsMidi() const override; // Determines if the plugin accepts MIDI input\n"
"\tbool producesMidi() const override; // Determines if the plugin produces MIDI output\n"
"    bool isMidiEffect() const override; // Determines if the plugin is a MIDI effect\n"
"\n"
"    double getTailLengthSeconds() const override; // Returns the tail length of the plugin in seconds\n"
"\n"
"    //==============================================================================\n"
"    int getNumPrograms() override; // Returns the number of programs (presets) available in the plugin\n"
"    int getCurrentProgram() override; // Returns the index of the current program\n"
"    void setCurrentProgram(int index) override; // Sets the current program (preset) by index.\n"
"\n"
"    const juce::String getProgramName(int index) override; // Returns the name of the program (preset) at the given index\n"
"    void changeProgramName(int index, const juce::String& newName) override; // Changes the name of the program (preset) at the given index\n"
"\n"
"    //==============================================================================\n"
"    void getStateInformation(juce::MemoryBlock& destData) override; // Saves the plugin's state to a memory block\n"
"\n"
"    void setStateInformation(const void* data, int sizeInBytes) override; // Restores the plugin's state from a memory block\n"
"\n"
"    juce::AudioProcessorValueTreeState apvts; // Manages the plugin's parameters using a value tree state.\n"
"\n"
"private:\n"
"\n"
"\t//==============================================================================\n"
"    // Creates and returns the parameter layout for the plugin.\n"
"    juce::AudioProcessorValueTreeState::ParameterLayout createParameters();\n"
"\n"
"    // DSP components used in the plugin.\n"
"    juce::dsp::Chorus<float> chorus_; // Chorus effect processor.\n"
"    juce::dsp::IIR::Filter<float> filter_ch1_; // Band-pass filter for channel 1.\n"
"    juce::dsp::IIR::Filter<float> filter_ch2_; // Band-pass filter for channel 2.\n"
"    juce::dsp::DryWetMixer<float> mix_; // Wet/dry mix processor.\n"
"\n"
"    //==============================================================================\n"
"    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VirtualGramoAudioProcessor)\n"
"        // Macro to prevent copying and enable leak detection for the class.\n"
"};";

const char* PluginProcessor_h = (const char*) temp_binary_data_1937;

//================== PluginEditor.cpp ==================
static const unsigned char temp_binary_data_1938[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin editor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#include \"PluginEditor.h\" // Includes the header file for the plugin editor.\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor.\n"
"\n"
"\n"
"constexpr float LINE_THICKNESS = 4.0f; // Defines the thickness of lines drawn in the editor.\n"
"\n"
"//==============================================================================\n"
"// Constructor for the plugin editor.\n"
"VirtualGramoAudioProcessorEditor::VirtualGramoAudioProcessorEditor(VirtualGramoAudioProcessor& p)\n"
"    : AudioProcessorEditor(&p), audioProcessor(p), info_button_(juce::Colours::darkgrey)\n"
"{\n"
"    constexpr int TEXT_BOX_SIZE = 25; // Defines the size of the text box for sliders.\n"
"\n"
"    // Sets up the compression slider.\n"
"    compressThreshParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag); // Rotary slider style.\n"
"    compressThreshParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE); // No text box for the slider.\n"
"    compressThreshParam.addListener(this); // Adds this editor as a listener for slider changes.\n"
"    addAndMakeVisible(compressThreshParam); // Makes the slider visible in the editor.\n"
"\n"
"    // Links the compression slider to the \"COMPRESS\" parameter in the processor's parameter tree.\n"
"    compressThreshAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"COMPRESS\", compressThreshParam);\n"
"\n"
"    // Sets up the tone slider.\n"
"    toneParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    toneParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    toneParam.addListener(this);\n"
"    addAndMakeVisible(toneParam);\n"
"    toneAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"TONE\", toneParam);\n"
"\n"
"    // Sets up the vibrato slider.\n"
"    vibratoDepthParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    vibratoDepthParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    vibratoDepthParam.addListener(this);\n"
"    addAndMakeVisible(vibratoDepthParam);\n"
"    vibratoDepthAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"VIBRATO_DEPTH\", vibratoDepthParam);\n"
"\n"
"    // Sets up the vibrato rate slider.\n"
"    vibratoRateParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    vibratoRateParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    vibratoRateParam.addListener(this);\n"
"    addAndMakeVisible(vibratoRateParam);\n"
"    vibratoRateAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"VIBRATO_RATE\", vibratoRateParam);\n"
"\n"
"    // Sets up the mix slider.\n"
"    wetDryParam.setSliderStyle(juce::Slider::SliderStyle::RotaryHorizontalVerticalDrag);\n"
"    wetDryParam.setTextBoxStyle(juce::Slider::NoTextBox, true, TEXT_BOX_SIZE, TEXT_BOX_SIZE);\n"
"    wetDryParam.addListener(this);\n"
"    addAndMakeVisible(wetDryParam);\n"
"    wetDryAttach = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(audioProcessor.apvts, \"MIX\", wetDryParam);\n"
"\n"
"    // Adds the info button to the editor.\n"
"    info_button_.addToEditor(this);\n"
"\n"
"\t//addAndMakeVisible(gramoModelLoader); // Adds the model loader to the editor.\n"
"\n"
"    setSize(1500, 1500); // Sets the initial size of the editor window.\n"
"\tsetResizable(true, true);\n"
"}\n"
"\n"
"// Destructor for the plugin editor.\n"
"VirtualGramoAudioProcessorEditor::~VirtualGramoAudioProcessorEditor()\n"
"{\n"
"    \n"
"}\n"
"\n"
"//==============================================================================\n"
"// Paints the editor's GUI components.\n"
"void VirtualGramoAudioProcessorEditor::paint(juce::Graphics& g)\n"
"{\n"
"    // (Our component is opaque, so we must completely fill the background with a solid colour)\n"
"    g.fillAll(juce::Colours::beige);\n"
"\n"
"    g.setColour(juce::Colour(0xff123456));\n"
"    g.setFont(40.0f);\n"
"    g.drawFittedText(\"Virtual Gramophone\", getLocalBounds(), juce::Justification::centredTop, 1);\n"
"\n"
"    // Draw contours\n"
"    g.setColour(juce::Colour(0xff123456));\n"
"    DrawThreePointLine(g, 73.0f, 179.0f, 62.0f, 144.0f, 8.0f, 102.0f);\n"
"    DrawThreePointLine(g, 85.0f, 189.0f, 83.0f, 133.0f, 43.0f, 48.0f);\n"
"    DrawThreePointLine(g, 92.0f, 193.0f, 105.0f, 129.0f, 113.0f, 38.0f);\n"
"    DrawThreePointLine(g, 101.0f, 201.0f, 144.0f, 126.0f, 194.0f, 55.0f);\n"
"    DrawThreePointLine(g, 108.0f, 203.0f, 176.0f, 145.0f, 258.0f, 109.0f);\n"
"    DrawThreePointLine(g, 122.0f, 209.0f, 188.0f, 179.0f, 279.0f, 171.0f);\n"
"    DrawThreePointLine(g, 136.0f, 211.0f, 174.0f, 202.0f, 252.0f, 225.0f);\n"
"    DrawThreePointLine(g, 108.0f, 203.0f, 144.0f, 215.0f, 174.0f, 245.0f);\n"
"    DrawThreePointLine(g, 108.0f, 203.0f, 73.0f, 179.0f, 25.0f, 166.0f);\n"
"    g.drawLine(juce::Line<float>(108.0f, 203.0f, 92.0f, 229.0f), LINE_THICKNESS);\n"
"\n"
"    SetupSections();\n"
"    g.setFont(18.0f);\n"
"    g.drawFittedText(\"COMP\", compressTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"TONE\", toneTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"VIBE\", vibratoTextSection, juce::Justification::left, 1);\n"
"    g.drawFittedText(\"DRY\", wetDryTextSection, juce::Justification::left, 1);\n"
"}\n"
"\n"
"// Converts a slider's value to an alpha (transparency) value.\n"
"float VirtualGramoAudioProcessorEditor::sliderToAplhaValue(juce::Slider& slider)\n"
"{\n"
"    double range = (slider.getMaximum() - slider.getMinimum());\n"
"    return static_cast<float>((slider.getValue() - slider.getMinimum()) / range);\n"
"}\n"
"\n"
"// Draws a line connecting three points.\n"
"void VirtualGramoAudioProcessorEditor::DrawThreePointLine(juce::Graphics& g,\n"
"    float x1,\n"
"    float y1,\n"
"    float x2,\n"
"    float y2,\n"
"    float x3,\n"
"    float y3)\n"
"{\n"
"    g.drawLine(juce::Line<float>(x1, y1, x2, y2), LINE_THICKNESS);\n"
"    g.drawLine(juce::Line<float>(x2, y2, x3, y3), LINE_THICKNESS);\n"
"}\n"
"\n"
"// Handles resizing and layout of GUI components.\n"
"void VirtualGramoAudioProcessorEditor::resized()\n"
"{\n"
"    info_button_.button.setBounds(getWidth() - 35, 10, 20, 20); // Positions the info button.\n"
"    info_button_.info_text.setBounds(30, 50, getWidth() - 60, getHeight() - 100); // Positions the info text.\n"
"    SetupSections(); // Updates the layout sections.\n"
"    compressThreshParam.setBounds(compressSection); // Positions the compression slider.\n"
"    toneParam.setBounds(toneSection); // Positions the tone slider.\n"
"    vibratoDepthParam.setBounds(vibratoDepthSection); // Positions the vibrato slider.\n"
"    vibratoRateParam.setBounds(vibratoRateSection); // Positions the vibrato rate slider.\n"
"    wetDryParam.setBounds(wetDrySection); // Positions the mix slider.\n"
"\n"
"\n"
"    std::string GramoSuite = \"GramoSuite.fbx\"; // Path to an FBX file\n"
"    //gramoModelLoader.importModel(GramoSuite); // Import the model from the specified path\n"
"    //gramoModelLoader.setBounds(pictureSection);\n"
"}\n"
"\n"
"// Sets up the layout sections for the GUI.\n"
"void VirtualGramoAudioProcessorEditor::SetupSections()\n"
"{    \n"
"    juce::Rectangle<int> r = getLocalBounds(); // Gets the bounds of the editor.\n"
"    topSection = r.removeFromTop(50); // Allocates the top section.\n"
"    pictureSection = r.removeFromLeft(310); // Allocates the picture section.\n"
"\n"
"    juce::Rectangle<int> interfaceSection = r; // Remaining area for the interface.\n"
"    int section_height = interfaceSection.getHeight() / 4; // Divides the interface into four sections.\n"
"    constexpr int textSectionWidth = 40; // Width for the text labels.\n"
"\n"
"    // Allocates sections for sliders and their labels.\n"
"    compressSection = interfaceSection.removeFromTop(section_height);\n"
"    compressTextSection = compressSection.removeFromLeft(textSectionWidth);\n"
"\n"
"\ttoneSection = interfaceSection.removeFromTop(section_height);\n"
"\ttoneTextSection = toneSection.removeFromLeft(textSectionWidth);\n"
"\n"
"\tvibratoDepthSection = interfaceSection.removeFromTop(section_height);\n"
"\tvibratoTextSection = vibratoDepthSection.removeFromLeft(textSectionWidth);\n"
"\tvibratoRateSection = interfaceSection.removeFromTop(section_height);\n"
"\n"
"    wetDrySection = interfaceSection;\n"
"    wetDrySection = interfaceSection.removeFromTop(textSectionWidth);\n"
"}\n"
"\n"
"// Callback for when a slider's value changes.\n"
"void VirtualGramoAudioProcessorEditor::sliderValueChanged(juce::Slider* /*slider*/)\n"
"{\n"
"    repaint(); // Repaints the editor to reflect the updated slider value.\n"
"}";

const char* PluginEditor_cpp = (const char*) temp_binary_data_1938;

//================== PluginEditor.h ==================
static const unsigned char temp_binary_data_1939[] =
"/*\n"
"  ==============================================================================\n"
"\n"
"    This file contains the basic framework code for a JUCE plugin editor.\n"
"\n"
"  ==============================================================================\n"
"*/\n"
"\n"
"#pragma once // Ensures the file is included only once during compilation.\n"
"\n"
"#include \"PluginProcessor.h\" // Includes the header file for the plugin processor.\n"
"#include \"InfoButton.h\"      // Includes the header file for the InfoButton class.\n"
"#include <JuceHeader.h>      // Includes the JUCE framework header file.\n"
"//#include <../Source/UI/GramoModelLoader.h>\n"
"\n"
"\n"
"//==============================================================================\n"
"/**\n"
" * The main editor class for the plugin.\n"
" * Inherits from juce::AudioProcessorEditor and juce::Slider::Listener.\n"
" * Handles the GUI and user interactions for the plugin.\n"
" */\n"
"class VirtualGramoAudioProcessorEditor : public juce::AudioProcessorEditor,\n"
"    public juce::Slider::Listener\n"
"{\n"
"public:\n"
"    explicit VirtualGramoAudioProcessorEditor(VirtualGramoAudioProcessor&); // Constructor that takes a reference to the audio processor.\n"
"    ~VirtualGramoAudioProcessorEditor() override; // Destructor for the editor.\n"
"\n"
"    //==============================================================================\n"
"    void paint(juce::Graphics&) override; // Paints the editor's GUI components.\n"
"    void DrawThreePointLine(juce::Graphics&, float x1, float y1, float x2, float y2, float x3, float y3); // Custom method to draw a line connecting three points.\n"
"    void resized() override; // Handles resizing and layout of GUI components.\n"
"\n"
"\n"
"private:\n"
"    float sliderToAplhaValue(juce::Slider& slider); // Converts a slider's value to an alpha (transparency) value.\n"
"    void SetupSections(); // Sets up the layout and sections of the GUI.\n"
"    void sliderValueChanged(juce::Slider* slider) override; // Callback for when a slider's value changes.\n"
"\n"
"    InfoButton info_button_; // Custom button for displaying information about the plugin.\n"
"\n"
"    // Type alias for a unique pointer to a SliderAttachment.\n"
"    typedef std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> SliderAttatchmentPtr;\n"
"\n"
"    // Sliders for controlling various parameters of the plugin.\n"
"    juce::Slider compressThreshParam; // Slider for controlling the compression parameter.\n"
"    SliderAttatchmentPtr compressThreshAttach; // Attachment to link the compress slider to the parameter tree.\n"
"\n"
"    juce::Slider toneParam; // Slider for controlling the tone parameter.\n"
"    SliderAttatchmentPtr toneAttach; // Attachment to link the tone slider to the parameter tree.\n"
"\n"
"    juce::Slider vibratoDepthParam; // Slider for controlling the vibrato depth parameter.\n"
"    SliderAttatchmentPtr vibratoDepthAttach; // Attachment to link the vibrato slider to the parameter tree.\n"
"\n"
"    juce::Slider vibratoRateParam; // Slider for controlling the vibrato rate parameter.\n"
"    SliderAttatchmentPtr vibratoRateAttach; // Attachment to link the vibrato rate slider to the parameter tree.\n"
"\n"
"    juce::Slider wetDryParam; // Slider for controlling the wet/dry mix parameter.\n"
"    SliderAttatchmentPtr wetDryAttach; // Attachment to link the mix slider to the parameter tree.\n"
"\n"
"    // Rectangles defining sections of the GUI layout.\n"
"    juce::Rectangle<int> topSection; // Rectangle for the top section of the GUI.\n"
"    juce::Rectangle<int> pictureSection; // Rectangle for the picture section of the GUI.\n"
"    juce::Rectangle<int> compressSection; // Rectangle for the compression slider section.\n"
"    juce::Rectangle<int> toneSection; // Rectangle for the tone slider section.\n"
"    juce::Rectangle<int> vibratoDepthSection; // Rectangle for the vibrato slider section.\n"
"    juce::Rectangle<int> vibratoRateSection; // Rectangle for the vibrato rate slider section.\n"
"    juce::Rectangle<int> wetDrySection; // Rectangle for the mix slider section.\n"
"    juce::Rectangle<int> compressTextSection; // Rectangle for the compression text label section.\n"
"    juce::Rectangle<int> toneTextSection; // Rectangle for the tone text label section.\n"
"    juce::Rectangle<int> vibratoTextSection; // Rectangle for the vibrato text label section.\n"
"    juce::Rectangle<int> wetDryTextSection; // Rectangle for the mix text label section.\n"
"\n"
"\t//GramoModelLoader gramoModelLoader; // Instance of the GramoModelLoader class for loading 3D models.\n"
"\n"
"    VirtualGramoAudioProcessor& audioProcessor; // Reference to the audio processor instance.\n"
"\n"
"    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(VirtualGramoAudioProcessorEditor)\n"
"        // Macro to prevent copying and enable leak detection for the class.\n"
"};\n";

const char* PluginEditor_h = (const char*) temp_binary_data_1939;

//================== InfoButton.cpp ==================
static const unsigned char temp_binary_data_1940[] =
"#include \"InfoButton.h\"\n"
"\n"
"InfoButton::InfoButton (juce::Colour colour)\n"
"{\n"
"    button.setButtonText (\"i\");\n"
"    button.addListener (this);\n"
"\n"
"    info_text.setColour (juce::Label::backgroundColourId, colour);\n"
"    info_text.setColour (juce::Label::outlineColourId, juce::Colours::white);\n"
"    info_text.setColour (juce::Label::textColourId, juce::Colours::lightgrey);\n"
"    info_text.setJustificationType (juce::Justification::centredLeft);\n"
"    info_text.setBorderSize (juce::BorderSize<int> (20, 70, 20, 70));\n"
"\n"
"    std::string info_string = \"\";\n"
"    info_string += ProjectInfo::companyName + std::string (\" \") + ProjectInfo::projectName + std::string (\" version \") + ProjectInfo::versionString + std::string (\"\\n\\n\");\n"
"    info_string += std::string (\"by Montague Whishaw\\n\\n\");\n"
"    info_string += std::string (\"Check out my other projects at https://github.com/MontagueWh\");\n"
"\n"
"    info_text.setText (info_string, juce::dontSendNotification);\n"
"}\n"
"\n"
"InfoButton::~InfoButton() {}\n"
"\n"
"void InfoButton::addToEditor (juce::AudioProcessorEditor* editor)\n"
"{\n"
"    editor->addAndMakeVisible (info_text);\n"
"    info_text.setVisible (false);\n"
"    editor->addAndMakeVisible (button);\n"
"}\n"
"\n"
"void InfoButton::buttonStateChanged (juce::Button* b)\n"
"{\n"
"    if (b == &button)\n"
"    {\n"
"        if (button.isOver())\n"
"        {\n"
"            info_text.setVisible (true);\n"
"        }\n"
"        else\n"
"        {\n"
"            info_text.setVisible (false);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"void InfoButton::buttonClicked (juce::Button* button)\n"
"{\n"
"}\n";

const char* InfoButton_cpp = (const char*) temp_binary_data_1940;

//================== InfoButton.h ==================
static const unsigned char temp_binary_data_1941[] =
"#pragma once\n"
"\n"
"#include <JuceHeader.h>\n"
"\n"
"// Use the info button class by\n"
"// 1) Create an InfoButton object\n"
"// 2) Make the button visible by  using the function addToEditor(this) from PluginEditor class\n"
"// 3) In resized() function set boundry of the public data members button and info_text\n"
"class InfoButton : public juce::Button::Listener\n"
"{\n"
"public:\n"
"    explicit InfoButton (juce::Colour colour);\n"
"    ~InfoButton();\n"
"    void addToEditor (juce::AudioProcessorEditor* editor);\n"
"    void buttonStateChanged (juce::Button* b) override;\n"
"    void buttonClicked (juce::Button* button) override;\n"
"    juce::TextButton button;\n"
"    juce::Label info_text;\n"
"};\n";

const char* InfoButton_h = (const char*) temp_binary_data_1941;
}
